---
layout: post
title: work-mysql8
date: 2024-06-19
tags: [mysql8]
author: chizzk
---
<h3>mysql 8.0.1</h3>
***
### 1.窗口函数：
>cume_dist() over  ： 
<br>
>dense_rank() over ： 不间断排序
<br>
>first value() over ： 第一个值
<br>
> last_value() over ：最后一个值
<br>
> lag() over ： 上一行
<br>
> lead() over ： 下一行
<br>
> ntile() over : 分桶
<br>
> percent_rank() over : 占比
<br>
> row_number() : 行号
### 2.新的join方式

>join实现方式<br>
> 旧有：<br>
> 1.simple nested loop<br>
> 2.index loop<br>
> 3.block loop<br>
新的：<br>
>hash join optimization
### 3.执行计划-命令
>1.explain format=tree<br>
>2.explain analyze
### 4.新特性
>1.对索引排序<br>
>2.函数式索引<br>
>3.where条件优化<br>
>4.自增列编码重复（5.7之前存在memory中 8之后存在redo log中）<br>
>5.死锁检测 innodb_status_output_locks<br>
>6.information_schema.(新增表)innodb_cached_indexes <br>
>7.锁  NOWAIT(不等待 直接返回)/SKIP LOCKED （返回没有被锁的数据）<br>
>8.redolog /undolog / doublewrite 优化（todo）<br>
>9.innodb_dedicated_server(自动配置)<br>
>10.秒加列（）针对5.7及之前版本时间优化（针对大数据量）<br>
### 5.索引
>1.索引匹配方式： <br>（1）全值索引 <br> （2）匹配最左前缀 <br> （3）匹配列前缀 <br>（4）匹配范围值 <br> （5）匹配某一列并范围查询另外一列
#### 5.1 索引实现原理
>1.myisam存储引擎：索引文件和数据文件是分开存储的 innodb：一起存储<br>
>2.hash表：数组+链表 ：问题：某一个或几个空间包含大量数据 其他位置没有数据 解决：只能在一定程度上减少哈希冲突的概率，对于哈希算法的要求比较高，
> 查询效率较低，hash表为无序表<br>
>3.二叉树：<br>
>4.b树： <br>
>5.b-树：每层的data占用了大量的存储空间  <br>
>6.b+树：将所有数据存放在叶子节点中 <br>
```
question1:你们公司的数据表创建的索引的树的高度是多少： 一般情况下，3-4层的B+树可以支撑千万级的数据量存储
question2:你们公司的生产环境中，主键是否是自增的？为什么？ 在满足业务系统的情况下，尽量自增，进行表创建的时候要创建一个跟业务无关的id来作为逐渐，并且设置为自增
```

#### 5.2 聚簇索引和非聚簇索引
>1.一张表中可以有多少个索引？：理论上没有限制，主要看列的个数和存储引擎的支持，每个存储引擎至少支持16索引<br>
>2.一个索引对应一棵树还是多个索引对应一棵树？一个索引对应一棵B+树<br>
>3.当一张表有多个索引的时候，数据存储几份？：1份<br>
>4.如果真实的数据行只存储一份的话，那么其他索引的叶子节点存储什么数据？ 聚簇索引的列的值<br>
> 在innodb存储引擎中，数据在进行插入的时候要求必须跟某一个索引绑定在一起存储，如果创建表的时候有主键，那么数据跟主键放在一起，如果没有主键，那么数据会跟唯一键放在一起，如果没有唯一键，那么系统会生成一个6字节的rowid来进行存储
> 跟数据绑定在一起的索引称之为聚簇索引<br>
> 没有跟数据绑定在一起的索引称之为非聚簇索引<br>
> 如果一张表中包含多个索引的话，那么一定会有一个聚簇索引，而其他索引的叶子节点中存储的值都是这个聚簇索引所对应的key值

#### 5.3 回表|索引覆盖
>当进行索引检索时，没有办法从索引中获取到要查询的全部列信息的时候就要去聚簇索引中找到与之匹配的记录，这个叫回表<br>
>索引覆盖：
> > 根据索引的值去索引的B+树上进行检索，可以获取到要查询到的全部列的数据，不需要回表，这个就叫索引覆盖<br>
> 
>最左匹配原则：
> >
---