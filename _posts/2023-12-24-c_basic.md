---
layout: post
title: c_basic
date: 2023-12-24
---

# C语言基础学习笔记

## 一、C语言概述

### 0、体系介绍

* C语言概述
    * 什么是C语言
    * 为什么学习C语言
    * Hello World
    * system函数
    * C语言编译过程
    * CPU内部结构与寄存器
    * 汇编语言
    * 集成开发环境IDE
* 数据类型
    * 常量与变量
    * 整型：int
    * sizeof 关键字
    * 字符型：char
    * 实型（浮点型）：float，double
    * 进制
    * 计算机内数据存储方式
    * 类型限定符
    * 字符串格式化输入输出
* 运算符与表达式
    * 常用运算符分类
    * 算术运算符
    * 赋值运算符
    * 比较运算符
    * 逻辑运算符
    * 运算符优先级
    * 类型转换
* 程序流程结构
    * 概述
    * 选择结构
    * 循环结构
    * 跳转语句：break，continue，goto
* 数组和字符串
    * 概述
    * 一维数组
    * 二维数组
    * 多维数组
    * 字符数组与字符串
* 函数
    * 概述
    * 函数的定义
    * 函数的调用
    * 函数的声明
    * main 函数与 exit 函数
    * 多文件编程
* 指针
    * 概述
    * 指针基础知识
    * 指针和数组
    * 多级指针
    * 指针和函数
    * 指针和字符串
    * 指针小结
* 内存管理
    * 作用域
    * 内存布局
    * 内存分区代码分析
* 复合类型（自定义类型）
    * 结构体
    * 共用体（联合体）
    * 枚举
    * typedef
* 文件操作
    * 概述
    * 文件指针
    * 文件的顺序读写
    * 文件的随机读写
    * Linux 和 Windows 文本文件的区别
    * 获取文件状态
    * 删除文件，重命名文件名
    * 文件缓冲区
* Unix/Linux环境使用

### 1、什么是C语言

* 语言是人和人交流，C语言是人和机器交流
* 应用：大型服务器、嵌入式、网络安全

### 2、为什么要学习C语言

#### 2.1、C语言特点

1）优点：

* 代码量小
* 执行速度快
* 功能强大
* 编程自由

2）缺点

* 代码实现周期长
* 可移植性较差
* 过于自由，经验不足容易出错
* 对平台库依赖较多

#### 2.2、C语言应用领域

* 网站后台程序
* 针对某个主题写出功能强大的程序库
* 大型游戏引擎
* 写出另一种语言
* 操作系统、驱动程序
* 嵌入式微处理器开发
* web开发
* 分布式开发
* 并行计算
* 游戏逻辑
* 桌面开发
* 虚拟技术
* 数据库
* 编译器
* 大数据
* 云存储

#### 2.3、C语言的简洁

* C语言仅有32 个关键字，9种控制语句，34种运算符

**32个关键字：**auto、break、case、switch、char、const、continue、default、do、double、else、enum、extern、float、for、goto、if、int、long、register、return、short、signed、sizeof、static、struct、typedef、unsigned、union、void、volatile（防止编译器优化）、while

**9中控制语句：** if-else、for、while、do-while、continue、break、switch、goto、return

**34种运算符：**

* 算术运算符：+、-、*、/、%、++、--
* 关系运算符：<、<=、==、>、>=、!=
* 位运算符：<<、>>、~、|、^、&
* 逻辑运算符：&&、||、！
* 赋值运算符：=及其拓展
* 条件运算符：?:
* 逗号运算符：,
* 指针运算符：*、&
* 求字节数：sizeof
* 强制类型转换：(类型)
* 分量运算符：->、.
* 下标运算符：[]
* 其他：()

### 3、Hello World

```c
//导入一个文件，stdio.h是一个标准库，标准输入输出库		.h头文件
//<>表示导入系统文件
//""表示导入自定义文件
#include<stdio.h>


//两个斜杠表示注释，行注释，只能注释一行

/*
块注释
可以多行注释
注释内容不参与程序编译
*/

//int 数据类型，整型，出现在函数中，表示函数的返回值类型
//main 程序的主函数，程序有且只有一个主函数	()里面表示函数的参数
//函数的参数可以有多个，使用逗号分隔

int main()
{

	//{}	函数体
	//printf	是stdio.h中系统提供的函数，表示在标准输出设备上打印字符串
	//""表示字符串
	//;表示一条语句的结束
    // \n是一个转义字符，表示换行
	printf("Hello World!\n");

	//return 出现在其他函数中，表示函数结束；出现在main函数中，表示程序结束
	//0表示函数的返回值类型，要和函数返回值类型对应
	return 0;
}
```

* Qt中，文件路径不能有中文，否则无法编译通过
* windows中gcc编译程序：

```shell
gcc -o E:/C/hello.exe E:/C/hello.c 		# 前面是可执行程序，后面是源文件，源文件可以有多个

//在linux下，是：
gcc -o E:/C/hello.out E:/C/hello.c 
```

### 4、system函数

调用系统的cmd命令。

#### 4.1、system函数的使用

```c
#include<stdlib.h>
int system(const char* command);
```

功能：在已经运行的程序中执行另外一个外部程序

参数：外部可执行程序的名字

返回值：成功返回0，失败返回其他任意数字

```c
#include<stdlib.h>
#include<stdio.h>

int main()
{

	// cmd 命令：calc，计算器；notepad：记事本；mspaint：画图板
	//system("calc");

	//可以打开一个外部的程序，如果带路径，需要使用双斜杠\\，或者使用一个正斜杠/也可以
	int value;
	value=system("D:\\WeChat\\WeChat.exe");
	printf("%d\n", value);
	return 0;
}
```

### 5、C语言编译过程

#### 5.1、C程序编译步骤

C代码编译成可执行程序可分为四步：

1）预处理：宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里不会进行语法检查

2）编译：检查语法，将预处理之后的文件编译成汇编文件

3）汇编：将汇编文件生成目标文件（二进制文件）

4）链接：C语言写的程序是依赖各种库的，编译之后还需要把库链接到最终的可执行程序中去

#### 5.2、gcc编译过程

* 分步编译：

```shell
预处理：gcc -E hello.c -o hello.i		# 只进行
编译：gcc -S hello.i -o hello.s
汇编：gcc -c hello.s -o hello.o
链接：gcc hello.o -o hello.exe
```

* 一步编译：

```shell
gcc -o hello.exe hello1.c hello2.c
```

* 常见代码问题：

1）编辑时异常

2）编译时异常

3）运行时异常

#### 5.3、程序执行时过程

外部存储设备（hello.exe） $\xleftrightarrow[保存]{加载}$ 内存（代码区，数据区，栈区，堆区）$\xleftrightarrow{数据交互：总线}$ 中央处理器（CPU：运算器，寄存器，控制器）

#### 5.3、查找程序所依赖的库

windows平台下，需要使用软件 Depends.exe

### 6、CPU内部结构与寄存器

#### 6.1、64位于32位系统的区别

* 寄存器是CPU内部最基本的存储单元
* CPU通过总线和外部设备进行交互，总线宽度是8位，寄存器也是8位的，这个CPU就是8位的
* 寄存器是32位的，总线是16位的，称为准32位的CPU
* 64位指令兼容32位的指令
* 64位的CPU架构上运行了64位的软件操作系统，这个系统就是64位的；64位的CPU架构上运行了32位的软件操作系统，这个系统就是32位的；64位软件不能在32位CPU上运行。

#### 6.2、寄存器名字

8位：A、B、C、D

16位：AX、BX、CX、DX

32位：EAX、EBX、ECX、EDX

64位：RAX、RBX、RCX、RDX

#### 6.3、寄存器、缓存、内存的关系

按与CPU的远近来分，离得最近的是寄存器，然后是缓存（CPU缓存），最后是内存

CPU计算时，先预先把要用到数据读到内存，然后再把即将要用的数据读到寄存器。

### 7、汇编语言和程序调试

#### 7.1、汇编语言：

mov 移动

add 添加

push 压栈

pop 出栈

call 调用

eax 32位寄存器

简单的加法计算：

```c
#include<stdio.h>

int main()
{
	//数据类型，定义整型变量
	int a;
	int b;
	int c;

	__asm
	{
		mov a, 3
		mov b, 4
		mov eax, a
		add eax, b
		mov c, eax


	}

	printf("%d\n", c);
	return 0;
}
```

#### 7.2、断点和单步调试

* 断点添加：在选中行单击，或者按f9
* 调试程序，在**调试**中选择开始调试，或按f5，快速调试
    * 逐语句执行，f11；逐过程执行，f10；跳出过程，shift+f10；停止调试，shift+f5

### 8、集成开发环境 IDE

代码编辑器、编译器、调试器、图形用户界面

#### 8.1、VS

整行复制：光标定位在该行任意位置，ctrl+c

整行剪切：光标定位在该行任意位置，ctrl+x

智能提示：ctrl+j

自动补全：tab

智能补全：alt+$\rightarrow$

大小写转换：选中内容，ctrl+shift+u

整行代码上下移动：alt+上下方向键

格式化代码：ctrl+k+f

#### 8.2、Qt Creator

格式化代码：ctrl+i

注释、取消注释：ctrl+/

自动完成函数定义：alt+enter

编译，但不调试，运行：ctrl+r

编译，不运行：ctrl+b

## 二、数据类型

### 1、常量与变量

#### 1.1、关键字

**C关键字共有32个**

1）数据类型关键字12个：

char、short、int、long（long long）、float、double、unsigned、signed、struct、union、enum、void

2）控制语句关键字12个：

if、else、switch、case、default、break、for、do，while、continue、goto、return

3）存储类关键字5个：

auto、extern、register、static、const

4）其他关键字3个：

sizeof、typedef、volatile（防止编译器优化）

#### 1.2、数据类型

数据类型的作用：编译器预算对象（变量）分配的内存空间大小

* **数据类型：**
    * **基本类型**
        * 整型：int、short、long
        * 字符型：char
        * 实型（浮点型）：float（单精度实型）、double（双精度实型）
    * **构造类型**
        * 数组类型
        * 结构体：struct
        * 联合类型：union
        * 枚举类型：enum
    * **指针类型：** （char *、 int *、int **等）

#### 1.3、常量

* 在程序运行过程中，其值不能被改变的量
* 常量一般出现在表达式或赋值语句中

**定义常量的方式：**

```c
const 数据类型 常量名=值; （在C语言中不安全，建议使用宏，在C++中安全）
#define 常量名 值
```

#### 1.4、变量

* 在程序运行过程中，其值可以被改变的量

* 占位符，%f 表示输出一个浮点型float，默认保留6位小数
    占位符，%lf 表示输出一个浮点型double
    占位符，%.2f 表示输出一个浮点型float，保留两位小数，在C中会四舍五入，在C++中不会四舍五入

    占位符，%.2lf 表示输出一个浮点型float，保留两位小数，在C中会四舍五入，在C++中不会四舍五入

变量定义格式：

```c
数据类型 变量名=值;
```



```c
#include<stdio.h>

//宏定义
#define PI 3.14159
int main()
{
	//const double pi = 3.14159265354;
	float r = 2;
	double s = PI * r * r;
	double l = 2 * PI * r;

	//占位符，%f 表示输出一个浮点型float，默认保留6位小数
	//占位符，%lf 表示输出一个浮点型double
	//占位符，%.2f 表示输出一个浮点型float，保留两位小数，在C中会四舍五入，在C++中不会四舍五入

	printf("圆的周长：%lf\n圆的面积：%.2lf\n", l, s);
	return 0;
}
```

*注：在定义局部变量可以在数据类型前面加修饰 auto, 也可以不加*

#### 1.5、标识符

1）命名规则：

* 不能使用关键字
* 允许使用字母、数字和下划线的组合
* 不允许以数字开头
* 标识符字母区分大小写
* 见名知意

### 2、整型：int

#### 2.1、整型变量的定义和输出

| 打印格式 |                 含义                  |
| :------: | :-----------------------------------: |
|    %d    |    输出一个有符号的十进制 int 类型    |
|    %o    |            八进制 int 类型            |
|    %x    | 十六进制 int 类型，字母以小写形式输出 |
|    %X    | 十六进制 int 类型，字母以大写形式输出 |
|    %u    |    输出一个无符号的十进制 int 类型    |

```c
#include<stdio.h>

int main0301()
{
	//无符号 unsigned；有符号 signed(可以省略，默认都是有符号的)
	//int a = -10;
	unsigned int b = -10;

	//%u 占位符，输出一个无符号的十进制 int 类型
	printf("%u\n", b);
	return 0;

}

int main(void)
{
	/*
	//进制相关的问题
	//二进制（0-1）、八进制（0-7）、十六进制（0-9 A-F）
	int a = 10;
	printf("%d\n", a);

	//%x 占位符，输出一个八进制 int 类型
	printf("%x\n", a);
	printf("%X\n", a);

	//%u 占位符，输出一个十六进制 int 类型
	printf("%o\n", a);
	*/


	//定义八进制数据，以0开头
	int a = 0123;

	//定义16进制数据，以0x开头
	int b = 0xabcdef;

	printf("%d %d\n", a, b);

	//计算机定义数据是，不可以直接定义二进制

	return 0;
}
```

#### 2.2、整型变量的输入

1）VS的C4996错误

**scanf 引起的安全警告问题**

由于微软在VS中不建议使用C的传统库函数 scanf，srtcpy，sprintf等，所以直接使用这些库函数会提示C4996错误。VS建议使用带_s的函数，如scanf_s，strcpy_s等函数，这些函数不是编撰C函数。

要继续使用此函数，要在源文件中添加宏来避免这个错误：

```c
#define _CRT_SECURE_NO_WARNINGS			# 这个宏放在程序第一行，其他位置依然会报错
#pragma warning(disable:4996)			# 或者使用这和
```

* 由于用户输入的可能不是期望的类型，但是依然按照期望的类型进行处理了，最终导致出错，因此是不安全的

#### 2.3 short、int、long、long long

| 数据类型  |                    占用空间                     |
| :-------: | :---------------------------------------------: |
|   short   |                      2字节                      |
|    int    |                      4字节                      |
|   long    | windows为4字节；linux下32位为4字节，64位为8字节 |
| long long |                      8字节                      |



### 3、sizeof 关键字

计算一个数据类型的大小，单位为字节。返回值为 size_t，在32位系统下是unsigned int，是一个无符号的整数。

```c
sizeof(数据类型)	//或者		
sizeof(变量名)
```

*注：整型数据在内存中的占据内存大小与操作系统有关，但是：*

**short<=int <=long<long long**

*当一个小的类型赋值给大的类型，不会有丢失，但是反过来会有丢失*

### 4、字符型

#### 4.1、字符型变量的输入输出

**char	存储一个字符	占用一个字节	单引号''**

字符型存储时，存放的是字符对应的ASCII码，实际上字符型是一个一字节的整型数据。

* 字符型变量

```c
char ch='a';
```

* 打印字符型变量

```c
printf("%c\n",ch);
```

* 打印字符对应的十进制

```c
printf("%d\n",ch);
```

*  ASCII码：

空格：32

‘0’：48

'A'：65

'a'：97

* 字符型也可以进行加、减运算

```c
char ch1='a';
char ch2='A';
printf("%d\n",ch1-ch2);

```

* 小写字母转大写字母，减32；大写字母转小写字母，加32

#### 4.2、转义字符

| 转义字符 |                 含义                 |   ASCII码   |
| :------: | :----------------------------------: | :---------: |
|   `\a`   |                 警报                 |     007     |
|   `\b`   |                 退格                 |     008     |
|   `\f`   |                 换页                 |     012     |
|   `\n`   |                 换行                 |     010     |
|   `\r`   |                 回车                 |     013     |
|   `\t`   |              水平制表符              |     009     |
|   `\v`   |              竖直制表符              |     011     |
|   `\\`   |                反斜线                |     092     |
|   `\'`   |                单引号                |     039     |
|   `\"`   |                双引号                |     034     |
|   `\?`   |                 问好                 |     063     |
|   `\0`   |                数字0                 |     000     |
|  `\ddd`  |      8进制转义字符，d的范围0-7       |  3位八进制  |
|  `\xhh`  | 16进制转义字符，h的范围0-9，a-f，A-F | 3位十六进制 |

**打印%也需要进行转义：`\%`**

### 5、实型（浮点型）：float，double

* double类型比float表示的浮点型精度更高。
* 由于存储单元有限，因此浮点型的表示精度也是有限的，存在误差。
* 占位符 %lf 表示double型的输出，但是使用 %f 也可以

#### 5.1、sizeof 字节大小

* float：4字节
* double：8字节

**浮点型在内存中的存储分为三部分：**

* 符号位
* 指数为
* 小数位

**占位符	%p	以无符号十六进制显示内存的地址：** 

```c
int a=10;
float b=3.14;
printf("%p\n",&a);
printf("%p\n",&b);
```

*大小端对齐存储*

#### 5.2、以科学计数法表示浮点型数据

```c
float a=3.2e2f;

float b=3.2e-2f;

float c=3210.454;
printf("%e\n",c);

float d=0.123456;
printf("%e\n",d);
```

### 6、进制

x进制就是逢x进一。

#### 6.1、二进制

基数为2，逢二进一，借一当二。

**数据在计算机中主要是以补码的形式存储的。**

1）十进制转二进制

除二反序取余法

2）二进制转十进制

权值法：将一个二进制从末尾开始乘以二的n次幂，n从0开始

1010 $\rightarrow$ 0 * 2^0+1 * 2^1+0 * 2^2+1 * 2^3=10

3）十进制转八进制

除八反序取余法

4）八进制转十进制

权值法：将一个八进制从末尾开始乘以八的n次幂，n从0开始

5）十进制转十六进制

除十六反序取余法

6）十六进制转十进制

权值法：将一个十六进制从末尾开始乘以十六的n次幂，n从0开始

7）二进制和八进制、十六进制之间的转换

* 8421法则：二进制转十进制，从右往左，分别对应1,2,4,8，……
* 二进制转八进制：二进制从右往左，三位一组，将三位二进制转换成一位八进制
* 八进制转二进制：一位八进制转换成三位二进制
* 二进制转十六进制：二进制从右往左，四位一组，将四位二进制转换成一位十六进制
* 十六进制转二进制：一位十六进制转换成四位二进制

### 7、计算机内数据的存储方式

#### 7.1、小数转二进制

**十进制小数转二进制，小数部分和2相乘，取整数，不足1取0，每次相乘都是小数部分，顺序看取整后的数就是转化后的结果**

例如：0.432

0.432*2=（0）（0.864） * 2=（1）（0.728） * 2=（1）（0.456）

由于0.432三位小数，因此结果就只需取三位，对应的二进制结果为0.011

#### 7.2、内存单位

|     术语     |                    含义                     |
| :----------: | :-----------------------------------------: |
| bit（比特）  |              一个二进制的一位               |
| Byte（字节） | 一个字节为8位二进制，计算机中最小的存储单元 |

#### 7.3、原码

原码：数字的二进制形式

* 最高位作为符号位，0表示正，1表示负
* 其他数值部分就是数值本身绝对的二进制数
* 负数的原码是在其绝对值的原码的基础上，符号位为1

#### 7.4、反码

* 对于 正数，反码与原码相同
* 对于负数，符号位不变，其他部分按位取反

#### 7.5、补码

**在计算机系统中，数值一律用补码来存储**

* 对于正数，原码、反码、补码相同
* 对于负数，其补码为反码加1
* 补码符号位不动，其他位取反，最后整个数加1，得到原码

补码运算的优点：

* 统一了0的编码
* 将符号位和其他位统一处理
* 将减法运算转换为加法运算
* 两个用补码表示的数相加时，如果最高位（符号位）有进位，则进位直接舍弃

**零在计算机中的存储方式：0000 0000**

#### 7.6、有符号数和无符号数的取值范围

**有符号：**

数据存储时，将`-0`对应的区间值，设为最小的负数，例如8位，就是-128

有符号字符型取值范围：[-2^7, 2^7-1]

signed int 	32bit：[-2^31, 2^31-1]

long long 	64bit：[-2^61, 2^61-1]

short	2bit：[2^-15, 2^15-1]

long	32bit：[-2^31, 2^31-1]

**无符号：**

unsigned char：[0, 2^8-1]

unsigned int：[0, 2^32-1]

unsigned long：[0, 2^32-1]

unsigned short：[0, 2^16-1]

### 8、数据溢出

```c
char ch=127;
ch+=2;
printf("%d\n",ch);		//-127
```

* 当超过一个数据类型能够存放的最大范围时，数值会溢出。
* 有符号位最高位溢出：符号位溢出会导致数的正负发生变化，最高位溢出会导致最高位丢失

### 9、类型限定

|  限定符  |                             说明                             |
| :------: | :----------------------------------------------------------: |
|  extern  | 声明一个变量，extern声明的变量没有建立存储空间。extern int a; //变量a在定义的时候没有创建存储空间，告诉编译器有这么一个变量，但是没有告诉内存 |
|  const   |       定义一个常量，常量的值不能修改。const int a=10;        |
| volatile | 防止编译器优化代码，平时不会使用，只有实现特定功能的代码的时候会使用，防止因为编译器的优化而使代码在某些情况下出错 |
| register | 定义寄存器变量，提高效率，register 是建议型的指令，而不是命令型的指令，如果CPU 有空闲的寄存器，那么 register 就生效，如果没有空闲的寄存器，那么 register 就无效。 |

计算机中的变量在存储的时候分三步：1）声明；2）定义；3）使用

### 10、字符串的格式化输入和输出

#### 10.1、字符串常量

* 字符串是内存中一段连续的 char 空间，以 '\0' 结尾
* 字符串常量是由双引号括起来的字符序列，如 "china"
* 字符串常量和字符常量不同：
    * "a" 为字符串常量，编译器会自动在末尾添加一个结束标志位 '\0'，即 "a" 包含两个字符 'a' 和 '\0'，占两个字节空间
    * 'a' 为字符常量，占一个字节空间
* 占位符 %s 表示输出一个字符串，遇到 \0 停止，例如：

```c
char *a="hello \0 world"
printf("%s\n",a);		//输出为 hello

char *b="hello world"
printf("%s\n",b);		//输出为 hello world

char *c[11]="hello world"
printf("%s\n",c);		//输出为 hello world83w90mfi3	由于只有11个字节位置，没有空间存储结束标志符 \0 ,%s 在输出的时候找不到结束位置，就会一直往后读取内存，直到遇到 \0 为止，额外输出的内容是不确定的
```

#### 10.2、printf 函数和 putchar 函数

printf 是输出一个字符串，putchar 是输出一个 char

1）printf

| 打印格式 |  对应数据类型  |                             含义                             |
| :------: | :------------: | :----------------------------------------------------------: |
|    %d    |      int       |           接受整数值并将它表示为有符号的十进制整数           |
|   %hd    |   short int    |                           短整型数                           |
|   %hu    | unsigned short |                         无符号短整数                         |
|    %o    |  unsigned int  |                         无符号八进制                         |
|    %u    |  unsigned int  |                         无符号十进制                         |
|  %x, %X  |  unsigned int  |        无符号十六进制，%x 对应 abcdef，%X 对应 ABCDEF        |
|    %f    |     float      |                         单精度浮点数                         |
|   %lf    |     double     |                         双精度浮点型                         |
|  %e, %E  |     double     |     科学计数法表示的数，e 和 E 分别对应输出时的 e 的形式     |
|    %c    |      char      |     字符型，可以把输入的数字按照ASCII码转换为相应的字符      |
|    %s    |     char *     | 字符串，输出字符串中的字符直至遇到字符串中的空字符（\0）为止 |
|    %p    |     void *     |                    以十六进制形式输出指针                    |
|    %%    |       %        |                        输出一个百分号                        |

printf 附加格式：

|        字符         |                             含义                             |
| :-----------------: | :----------------------------------------------------------: |
|      l(字母l)       |               附加在d，u，x，o前面，表示长整数               |
|          -          |                            左对齐                            |
|  m（代表一个整数）  |                         数据最小宽度                         |
|     0（数字0）      |    将输出的前面补上0直到占满指定列宽为止，不可以搭配使用-    |
| m.n（代表一个整数） | m指定域宽，即对应的输出项在输出设备上所占的字符数，n值精度，用于说明输出的实型数的小数位数，对于数值型来说，未指定n时，默认的精度 n=6 |

```c
int a=10;
printf("%d\n",a);		//10
printf("===%-5d===\n",a);		//===10   ===
printf("===%5d===\n",a);		//===   10===	默认右对齐
printf("===%05d===\n",a);		//===00010===

int b=123456;
printf("===%05d===\n",b);		//===123456===	数据的长度大于指定的域宽，就直接输出，若小于，则使用指定字符填充

float c=3.14;
printf("%3.2f\n",c);			//3.14
printf("%===7.2f===\n",c);		//===   3.14===	m表示正体的宽度
printf("%===07.2f===\n",c);		//===0003.14===	m表示正体的宽度
printf("%===-7.2f===\n",c);		//===3.14   ===	m表示正体的宽度
```

2）putchar

```c
char ch='a';
//输出字符
printf("%c\n",a);		//a

//putchar
putchar(ch);			//a
putchar('B');			//B
putchar(97);			//a

//输出转义字符
putchar('\n');			//输出一个换行符
```

* putchar 输出字符，可以是变量，字符，数字（0-127），转义字符

#### 10.3、scanf 函数和 getchar 函数

* getchar 是从标准输入设备读取一个 char
* scanf 同过 %  转义的方式可以得到用户通过标准输入设备输入的数据

1）scanf

```c
char ch;
scanf("%c",&ch);
putchar(ch);

int a,b;
scanf("%d%d",&a,&b);			//有多个占位符的时候，输入通过空格或者换行来进行分割，这里可以输入12 34，也可以输入12\n34
scanf("%d,%d",&a,&b);			//也可以使用特定的分隔符，例如使用逗号，输入格式为：12,34。但是不能使用 \n 作为分隔符，因为使用 \n 会导致输入无法终止
printf("%d\t%d\n",a,b);

scanf("%3d,%d",&a,&b);			//使用域宽限制，可以对整型的输入进行限制，例如这里输入：123456
printf("%d\t%d\n",a,b);			//输出结果为：123        456
```

2）getchar

```c
char ch;

//接收键盘获取字符
ch=getchar();		//输入：b
putchar(ch);		//输出：b

ch=getchar();		//输入：abc
putchar(ch);		//输出：a	putchar只能输入一个字符

//在程序最后添加 getchar() ，可以使窗口停留等待，达到和 system("pause")类似的效果
getchar();
```

## 三、运算符与表达式

### 1、常用运算符分类

|  运算符类型  |                   作用                   |
| :----------: | :--------------------------------------: |
|  算术运算符  |             用于处理四则运算             |
|  赋值运算符  |         用于将表达式的值赋给变量         |
|  比较运算符  | 用于表达式的比较，并返回一个真值或者假值 |
|  逻辑运算符  |    用于根据表达式的值返回真值或者假值    |
|   位运算符   |           用于处理数据的位运算           |
| sizeof运算符 |             用于求字节数长度             |

### 2、算术运算符

| 运算符 |                           术语                           |
| :----: | :------------------------------------------------------: |
|   +    |                           正号                           |
|   -    |                           负号                           |
|   +    |                            加                            |
|   -    |                            减                            |
|   *    |                            乘                            |
|   \    | 除（两个整型数据相除，得到的结果是整型 -> 结果向下取整） |
|   %    |             取模（取余），只能对整型数据操作             |
|   ++   |                          前自增                          |
|   --   |                          前自减                          |
|   ++   |                          后自增                          |
|   --   |                          后自减                          |

* 除法运算：

```c
int a=10;
int b=3;
printf("%d\n",a/b);		//3		两个整型数据相除，得到的结果是整型 -> 结果向下取整

float c=10.0;
printf("%d\n",c/b);		//1.42857

int d=++a*10			//d=110, a=11
int e=b++*10			//e=30,b=4
```

* 前自增：先自增，再进行表达式计算
* 后自增：先进行表达式计算，再自增
* 前自减：先自减，再进行表达式计算
* 后自减：先进行表达式计算，再自减

**一般建议使用前自增和前自减，能够更具有可读性；后自增和后自减容易产生二义性****

**前置和后置混用，在不同操作系统由于实现不同会有不同的结果。**

### 3、赋值运算符

| 运算符 |  术语  |
| :----: | :----: |
|   =    |  赋值  |
|   +=   | 加等于 |
|   -=   | 减等于 |
|   *=   | 乘等于 |
|   /=   | 除等于 |
|   %=   | 模等于 |

### 4、比较运算符

比较完成后会返回真或假的布尔值

| 运算符 |   术语   |
| :----: | :------: |
|   ==   |  相等于  |
|  ！=   |  不等于  |
|   <    |   小于   |
|   >    |   大于   |
|   <=   | 小于等于 |
|   >=   | 大于等于 |

### 5、逻辑运算符

| 运算符 | 术语 |
| :----: | :--: |
|   ！   |  非  |
|   &&   |  与  |
|  \|\|  |  或  |

* 所有非零的值都是真
* ！ 非 ：非真为假，非假为真
* ！ 的优先级高于 && 
* 单目运算符优先级高于双目运算符，双目运算符优先级高于三目运算符
* && 与：同真为真，其余为假
* || 或：同假为假，其余为真

### 6、运算符的优先级

| 优先级 | 运算符 |   名称或含义   |         使用形式          | 结合方向 |    说明    |
| :----: | :----: | :------------: | :-----------------------: | :------: | :--------: |
|   1    |   []   |    数组下标    |    数组名[常量表达式]     |  左到右  |            |
|   1    |   ()   |     圆括号     | (表达式)，函数名(形参表)  |  左到右  |            |
|   1    |   .    |    成员对象    |        对象.成员名        |  左到右  |            |
|   1    |   ->   |    成员指针    |     对象指针->成员名      |  左到右  |            |
|   2    |   -    |   负号运算符   |          -表达式          |  右到左  | 单目运算符 |
|   2    |   ~    | 按位取反运算符 |          ~表达式          |  右到左  | 单目运算符 |
|   2    |   ++   |   自增运算符   |    ++变量名，变量名++     |  右到左  | 单目运算符 |
|   2    |   --   |   自减运算符   |    --变量名，变量名--     |  右到左  | 单目运算符 |
|   2    |   *    |   取值运算符   |         *指针变量         |  右到左  | 单目运算符 |
|   2    |   &    |  取地址运算符  |          &变量名          |  右到左  | 单目运算符 |
|   2    |   ！   |  逻辑非运算符  |         ！表达式          |  右到左  | 单目运算符 |
|   2    | (类型) |  强制类型转换  |     (数据类型)表达式      |  右到左  |            |
|   2    | sizeof |   长度运算符   |      sizeof(表达式)       |  右到左  |            |
|   3    |   /    |       除       |       表达式/表达式       |  左到右  | 双目运算符 |
|   3    |   *    |       乘       |       表达式*表达式       |  左到右  | 双目运算符 |
|   3    |   %    |      取余      |   整型表达式%整型表达式   |  左到右  | 双目运算符 |
|   4    |   +    |       加       |       表达式+表达式       |  左到右  | 双目运算符 |
|   4    |   -    |       减       |       表达式-表达式       |  左到右  | 双目运算符 |
|   5    |   <<   |      左移      |       变量<<表达式        |  左到右  | 双目运算符 |
|   5    |   >>   |      右移      |       变量>>表达式        |  左到右  | 双目运算符 |
|   6    |   >    |      大于      |       表达式>表达式       |  左到右  | 双目运算符 |
|   6    |   >=   |    大于等于    |      表达式>=表达式       |  左到右  | 双目运算符 |
|   6    |   <    |      小于      |       表达式<表达式       |  左到右  | 双目运算符 |
|   6    |   <=   |    小于等于    |      表达式<=表达式       |  左到右  | 双目运算符 |
|   7    |   ==   |      等于      |      表达式==表达式       |  左到右  | 双目运算符 |
|   7    |   !=   |     不等于     |      表达式!=表达式       |  左到右  | 双目运算符 |
|   8    |   &    |     按位与     |       表达式&表达式       |  左到右  | 双目运算符 |
|   9    |   ^    |    按位异或    |       表达式^表达式       |  左到右  | 双目运算符 |
|   10   |   \|   |     按位或     |      表达式\|表达式       |  左到右  | 双目运算符 |
|   11   |   &&   |     逻辑与     |      表达式&&表达式       |  左到右  | 双目运算符 |
|   12   |  \|\|  |     逻辑或     |     表达式\|\|表达式      |  左到右  | 双目运算符 |
|   13   |   ?:   |   条件运算符   | 表达式1？表达式2：表达式3 |  右到左  | 三目运算符 |
|   14   |   =    |   赋值运算符   |        变量=表达式        |  右到左  |            |
|   14   |   /=   |    除后赋值    |       变量/=表达式        |  右到左  |            |
|   14   |   *=   |    乘后赋值    |       变量*=表达式        |  右到左  |            |
|   14   |   %=   |   取模后赋值   |       变量%=表达式        |  右到左  |            |
|   14   |   +=   |    加后赋值    |       变量+=表达式        |  右到左  |            |
|   14   |   -=   |    减后赋值    |       变量-=表达式        |  右到左  |            |
|   14   |  <<=   |   左移后赋值   |       变量<<=表达式       |  右到左  |            |
|   14   |  >>=   |   右移后赋值   |       变量>>=表达式       |  右到左  |            |
|   14   |   &=   |  按位与后赋值  |       变量&=表达式        |  右到左  |            |
|   14   |   ^=   | 按位异或后赋值 |       变量^=表达式        |  右到左  |            |
|   14   |  \|=   |  按位或后赋值  |       变量\|=表达式       |  右到左  |            |
|   15   |   ,    |   逗号运算符   |    表达式，表达式，……     |  左到右  |            |

```c
int a=10;
int b=20;
int c=(a,b);		//c=20	逗号运算符是最后一个逗号右侧的表达式的值

int d=b=30;			//b=30,c=30
```

### 7、类型转换

类型转换有两种方法：

* 自动转换（隐式转换）：遵循一定的规则，由编译系统自动完成；
* 强制类型转换：把表达式运算的结果强制转换成所需的数据类型。

#### 7.1、隐式类型转换

类型转换的原则：占用内存字节数少的（值域小）的类型，向占用内存字节数多（值域大）的类型转换，以保证精度不降低。

**char, short $\rightarrow$ signed int $\rightarrow$ unsigned int $\rightarrow$ long $\rightarrow$ double**

**float $\rightarrow$ double** 

```c
float p=3.14;
int w=2;

//隐式类型转换
double sum=p*w;

```

#### 7.2、强制类型转换

强制类型转换运算符不会进行四舍五入，直接去尾

```c
float p=3.14;
int w=2;

//强制类型转换
//(数据类型)
int sum=(int)p*w;

int newSum=(int)(p*w);

```

### 8、程序流程结构

C语言支持三种程序运行结构：顺序结构、选择结构、循环结构

* 顺序结构：程序按顺序执行，不发生跳转
* 选择结构：依据是否满足条件，有选择的执行相应的功能
* 循环结构：依据条件是否满足，重复多次执行某段代码

#### 8.1、选择结构 - if 语句

* 如果表达式结果为真，执行 {} 对应的代码。

```c
// 形式1
if(表达式)
{}

//形式2
if(表达式)
{}
else
{}

//形式3
if(表达式1)
{}
else if(表达式2)
{}
else
{}


//条件嵌套
if(条件1)
{
    if(条件2)
    {}
    else if(条件2)
    {}
    else
    {}
}
else if(条件2)
{}
else
{}

```

#### 8.2、选择结构 - switch 语句

**switch 的执行效率高于 if-else 语句。**

```c
int score;
scanf("%d",&score);

//switch语句
switch (score/10)
{
    case 10:
        printf("优秀\n");
        break;
    case 9:
        printf("优秀\n");
        break;
    case 8:
        printf("良好\n");
        break;
    case 7:
        printf("良好\n");
        break;
    case 6:
        printf("及格\n");
        break;
    default:			//default 可以不要
        printf("不及格\n");
        break;
}

// break 一定要写，否则会将所有的条件都执行一遍
```

#### 8.3、 选择结构 - 条件运算符

三目运算符：

表达式1?表达式2:表达式3

```c
int a=10;
int b=20;

if(a>b)
{
	printf("a>b\n");
}
else
{
    printf("a<=b\n");
}

//三目运算符
a>b?printf("a>b\n"):printf("a<=b\n");
int c;
c=a>b?a:b;

//宏定义表达式
#define MAX(a,b) (a)>(b)?(a):(b)		//计算两数的较大者
int maxValue=MAX(a,b);
```

### 9、循环结构

#### 9.1、循环结构-while语句

```c
while(表达式)
{}


int i=1;
while(i<10)
{
    printf("%d\n",i);
    i++;
}

//100以内的偶数
int j=1;
while(j<=100)
{
    if(j%2==0)
    {
        printf("%d\n",j);
    }
    j++;
}

//7的倍数，数字带7,100以内
int k=1;
while(k<=100)
{
    if(k%7==0||k%10==7||k/10==7)
    {
        printf("%d\n",k);
    }
    k++;
}
```

#### 9.2、循环结构-do - while 语句

**do-while 语句与 while 语句的区别：while 语句先判断，再执行；do - while 语句先执行，再判断**

数学函数使用

```c
#include<math.h>

int c=pow(a,b);
```

#### 9.3、循环结构-for 语句

```c
//for 语句
for( ; ;)
{}

for(循环变量初始化表达式;条件判断表达式;改变循环变量)
{}
// 圆括号内的三个语句可以缺省
// 圆括号内的每个语句可以是多个语句使用逗号连接


for(int i=0;i<10;i++)
{
    printf("%d\n",i);
}

//上面的for循环等价于下面的写法
int i=0;
for( ; ; )
{
    if(i>=10)
    {
        break;
    }
    printf("%d\n",i);
    i++;
}
```

* gcc 编译的时候选择 c 的版本

```shell
# 使用 -std 参数设置C的版本
gcc -o hello.out hello.c -std=c99
```

* 产生随机数
    * 导入头文件 time.h	stdlib.h
    * 添加随机数种子
    * 获取随机数

```c
//产生随机数
srand((unsigned int)time(NULL));		//每次获取的随机数都不一样

int value=rand()%10;					//产生0-9的随机数
```

#### 9.4、嵌套循环

循环语句之间可以相互嵌套。

外层执行一次，内层执行一周。

```c
//sleep函数
#include<windows.h>

//电子时钟
for(int i=0;i<24;i++){
    for(int j=0;j<60;j++){
        for(int k=0;k<60;k++){
            
            //输出之前清屏
            system("cls");
            printf("%02d:%02d:%02d\n",i,j,k);
            //每次打印之后休眠1000毫秒
            Sleep(1000);
        }
    }
}


// 九九乘法口诀
/*
1*1=1
1*2=2 2*2=4
1*3=3 2*3=6 3*3=9
*/

for(int i=1;i<10;i++)
{
    for(int j=1;j<=i;j++)
    {
        printf("%d*%d=%d\t",j,i,i*j);
    }
    printf("\n");
}
```

### 10、跳转语句 break、continue、goto

#### 10.1、break 语句

switch 条件语句和循环语句中都可以使用 break 语句：

* 在 switch 语句中，作用是终止某个 case 并跳出 switch 结构；
* 在循环语句中，作用是跳出当前循环；
* 在嵌套循环语句中，退出当前所在层的循环语句，

#### 10.2、continue 语句

在循环语句中，跳过本次循环。

#### 10.3、goto 语句

无条件跳转，尽量少用。

* 跳转至另一个位置继续执行，跳过一些代码；
* 程序有多个出口，满足不同的条件，执行不同的出口，可以在不同出口前跳转；
* 不要在函数之间跳转
* 跳出死循环

```c
int mian()
{
    printf("Hello World1\n");
    printf("Hello World2\n");
    goto FLAG:
    printf("Hello World3\n");
    printf("Hello World4\n");
    FLAG:
    printf("Hello World5\n");
    printf("Hello World6\n");
    printf("Hello World7\n");
    printf("Hello World8\n");
    
    return 0;
}


//程序有多个出口，可以这样跳转
int mian()
{
    printf("Hello World1\n");
    printf("Hello World2\n");
    goto FLAG:
    printf("Hello World3\n");
    printf("Hello World4\n");
    printf("Hello World7\n");
    printf("Hello World8\n");
    
    return 0;
    
    FLAG:
    printf("Hello World5\n");
    printf("Hello World6\n");
    
    return 1;
}
```

## 四、数组和字符串

### 1、概述

* 数组是在内存中连续的相同类型的变量空间
* 数组属于构造数据类型

```c
//数组定义
//数据类型 数组名[元素个数]={值1，值2，值3，……};
int arr[10]={9,8,7,6,5,4,3,2,1,0};

//元素访问
//数组名[下标]
//数组下标从0开始
for(int i=0;i)
{
    printf("%d\n",arr[i]);
}

//数组在内存中的存储方式和大小
for(int i=0;i<10;i++)
{
    printf("%p\n",&arr[i]);
}

printf("%p\n",&arr);

printf("数组在内存中占的大小：%d\n",sizeof(arr));
printf("数组元素在内存中占的大小：%d\n",sizeof(arr[0]));
printf("数组元素个数：%d\n",sizeof(arr)/sizeof(arr[0]));
```

* 数组在内存中是连续存储的，地址连续
* 数组名是一个指向数组首地址的地址常量
* 数组在内存中占的大小：数组类型*元素个数

### 2、数组的定义和使用

```c
# 数组定义的方式
int arr1[10]={9,8,7,6,5,4,3,2,1,0};
int arr2[]={9,8,7,6,5,4,3,2,1,0};		//自动得到数组长度为10
int arr3[10]={1,2,3};		// 前三个分别为1 2 3 ，其余为0
int arr4[10]={0};			//所有元素都为0
int arr5[10]={1};			//第一个为1，其余为0

int arr6[10];				//定义了没有赋值，内部的数据不确定，一般会乱码
arr6[0]=1;					//第一个为1，其余依然乱码

int arr[];					//在这种写法不可以

//这种写法不可以，数组定义的时候，数组长度必须是常量，或者常量表达式
//数组必须预先知道大小
//动态数组	开辟堆空间
int i=10;
int arr[i];


//从键盘获取数组元素值
int arr7[10];
for(int i=0;i<10;i++){
    scanf("%d",&arr7[i]);
}


```

* 数组下标越界，可能会报错，但是越界后，访问到的内容不确定。下标越界，编译器不会报错

### 3、数组逆置


### 4、冒泡排序

```c
//内层比较次数为：元素个数-1-执行次数
//外层执行次数为：元素个数-1

```

### 5、二维数组

#### 5.1、二维数组的定义和使用

```c
// 一维数组：数据类型 数组名[元素个数]={值1，值2，……}
// 二维数组：数据类型 数组名[行数][列数]={{值1，值2，……},{值1，值2，……},{值1，值2，……},……}
int arr[2][3]={{1,2,3},{4,5,6}};

arr[1][2]=20;
for(int i=0;i<2;i++)
{
	for(int j=0;j<3;j++)
    {
        printf("%d ",arr[i][j]);
    }
    printf("\n");
}

printf("二维数组的大小：%d\n",sizeof(arr));
printf("二维数组一行的大小：%d\n",sizeof(arr[0]));
printf("二维数组的元素大小：%d\n",sizeof(arr[0][0]));

printf("二维数组的行数：%d\n",sizeof(arr)/sizeof(arr[0]));
printf("二维数组的列数：%d\n",sizeof(arr[0])/sizeof(arr[0][0]));

//二维数组首地址
//下面三个语句的输出结果一样
printf("%p\n",arr);
printf("%p\n",arr[0]);
printf("%p\n",&arr[0][0]);

//数组的第二行的首地址
printf("%p\n",arr[1]);

//二维数组初始化
int arr[2][2]={1,2,3,4,5,6};	//等价于 int arr[2][3]={{1,2,3},{4,5,6}}; 但是一般不要这么写，不方便维护

//int arr[2][3]
int arr[][3]={1,2,3,4,5,6};	

//int arr[3][3]
int arr[][3]={1,2,3,4,5,6,7};	

//二位数组初始化的时候，列数不能省略，只能省略行


```

#### 5.2、二维数组的应用

```c
//定义一个二位数组，存储五名学生三门成绩，arr[5][3]
//求出每名学生的总成绩，平均成绩
//求出每门课的总成绩，平均成绩
int arr[5][3];

//输入成绩
for(int i=0;i<5;i++)
{
    for(int j=0;j<3;j++)
    {
        scanf("%d",&arr[i][j]);
    }
}
//输出成绩
for(int i=0;i<5;i++)
{
    for(int j=0;j<3;j++)
    {
        printf("%d",&arr[i][j]);
    }
}

//计算每名学生的总成绩和平均成绩
for(int i=0;i<5;i++)
{
    int sum=0;
    for(int j=0;j<3;j++)
    {
        sum+=arr[i][j];
    }
    int average=sum/3;
}

//计算每门课的总成绩和平均成绩
for(int i=0;i<3;i++)
{
    int sum=0;
    for(int j=0;j<5;j++)
    {
        sum+=arr[i][j];
    }
    int average=sum/5;
}
```

### 6、多维数组

#### 6.1、多维数组的定义

```c
// 一维数组：数据类型 数组名[元素个数]={值1，值2，……}
// 二维数组：数据类型 数组名[行数][列数]={{值1，值2，……},{值1，值2，……},{值1，值2，……},……}
//多维数组声明：数组类型 数组名[n1][n2]……[nn];
int arr[2][3][4]={{{1,2,3,4},{2,3,4,5},{3,4,5,6}},{{4,5,6,7},{5,6,7,8},{6,7,8,9}}};
for(int i=0;i<2;i++)
{
	for(int j=0;j<3;j++)
    {
        for(int k=0;k<4;k++)
        {
            printf("%d ",arr[i][j][k]);
        }
        printf("\n");
    }
    printf("\n");
}


//三维数组的大小
printf("三维数组的大小：%d\n",sizeof(arr));
printf("三维数组一层的大小：%d\n",sizeof(arr[0]));
printf("三维数组一行的大小：%d\n",sizeof(arr[0][0]));
printf("三维数组元素的大小：%d\n",sizeof(arr[0][0][0]));

//三维数组的层数
printf("三维数组的层数：%d\n",sizeof(arr)/sizeof(arr[0]));
printf("三维数组的行数：%d\n",sizeof(arr[0])/sizeof(arr[0][0]));
printf("三维数组的列数：%d\n",sizeof(arr[0][0])/sizeof(arr[0][0][0]));

//三维数组定义的时候，层数可以省略
//高维数组定义的候，第一个维度可以省略
int arr[][3][4]={0}

//四维数组
int arr[2][3][4][5]={1,2,3};
//元素个数：2*3*4*5
```

### 7、字符数组和字符串

#### 7.1、字符数组与字符串的区别

```c
//定义字符数组
char arr[6]={'h','e','l','l','o','0'};	//此时不是字符串，只是字符数组
char arr2[5]={'h','e','l','l','o'};	
//字符
char ch='h';
//字符串	字符串结束标志位 \0
char *str="hello";
char arr1[]={'h','e','l','l','o','\0'};		//此时就是字符串了，数字0等同于 \0,，但是不等同于 '0'
printf("%s",arr1);
printf("%s",arr2);		//不会报错，但是输出会乱码

printf("%d\n",sizeof(arr));

//可以通过字符的ASCII码进行字符数组的初始化，但是下面的初始化末尾没有'\0'，因此输出完前7个字符之后，后面会乱码，直到遇到内存中的'\0'为止
char ch3[]={110,111,112,101,123,98,99};
printf("%s",ch3);

char ch4[]={"hello"};	//也可以，不要大括号也可以

```

#### 7.2、字符数组存储字符串

```c
//定义字符数组，存储字符串
char ch[10];

//输入：helloworld ，会报错
//输入：helloworl ，会正常输入输出
//输入：hellowo ，会正常输入输出
//输入：hello wor，会输出hello
scanf("%s",ch);		//在输入字符串的时候，长度超过9个会报错

printf("%s",ch);
```

* 拼接两个字符串

```c
char ch1[]="hello";
char ch2="world";
char ch3[30];

//字符串拼接
int i=0;
int j=0;
while(ch1[i]!='\0')
{
    ch3[i]=ch1[i];
    i++;
}
while(ch2[j]!='\0')
{
    ch3[i+j]=ch2[j];
    j++;
}
ch3[i+j]='\0';

printf("%s",ch3);
```

#### 7.3、字符串输入输出

```c
char ch[10];

//可以在输入的时候对字符串长度进行限定，这里输入超过9个字符就不会报错，但是实际输入只有九个字符，输出也只有9个字符
scanf("%9s",ch);		
printf("%s",ch);

```

1）gets() 函数：从标准输入读入字符，并保存到指定的内存空间，直到出现换行符或读到文件结尾为止

```c
char *gets(char *s);

```

* 参数：s，字符串首地址
* 返回值：成功，读入的字符串；失败，NULL
* gets(str) 和 scanf("%s",str) 的区别：
    * gets(str) 允许输入的字符串含有空格
    * scanf("%s",str) 不允许含有空格

```c
# include <stdio.h>
char ch[100];
char ch2[100];

//通过键盘获得一个字符串
//gets() 接收字符串可以带空格
//scanf 可以通过正则表达式来接收空格
scanf("%[^\n]",ch);
gets(ch);
printf("%s",ch);
```

**注：由于 scanf() 和 gets() 无法知道字符串的大小，必须遇到换行符或者读到文件结尾为止才接收输入，因此容易导致数组越界（缓冲区溢出）的情况。**

2）fgets() 函数：从 stream 指定的文件内读入字符，保存到所指定的内存空间，直到出现换行字符、读到文件末尾或是读了 size-1 个字符为止，最后会自动加上 '\0' 字符作为结束标志。

```c
# include<stdio.h>
char *fgets(char *s, int size,FILE *stream);
```

* 参数：
    * s，字符串；
    * size，指定最大读取字符串的长度（size-1）
    * stream：文件指针，如果读取键盘输入的字符串，固定写作 stdin
* 返回值：
    * 成功：成功读取的字符串
    * 读到文件尾或者出错：NULL
* fgets() 在读取一个用户通过键盘输入的字符串的时候，同事把用户输入的回车也作为字符串的一部分。通过 gets() 和 scanf() 输入一个字符串的时候，不包含结尾的 '\n'，**但通过 fgets() 结尾多了 '\n'**。
* fgets() 函数是安全的，不存在缓冲区溢出的问题
* fgets() 函数可以接收空格和换行
* fgets() 函数获取字符串长度短于元素个数会有 '\n'，大于则没有

```c
char ch[10];

fgets(ch,sieof(ch),stdin);
printf("%s",ch);
```

3）puts () 函数：从标准输出设备输出字符串，在输出完成后自动输出一个 '\n'

```c
#include<srdio.h>
int puts(const char *s);
```

* 参数：s，字符串首地址
* 返回值：成功，非负数；失败，-1

```c
char ch[]="hello world";

//puts() 自带换行
puts(ch);

puts("hello\0 world");		//输出结果为hello，输出的时候遇到 '\0' 停止

```

4）fputs() 函数：将 str 所指定的字符串写入到 stream 指定的文件中，字符串结束符 '\0' 不写入文件

```c
#include<stdio.h>
int fputs(const char *str,FILE *stream);
```

* 参数：
    * str，字符串
    * stream，文件指针，如果把字符串输出到屏幕，固定写为 stdout
* 返回值：成功，0；失败，-1
* fputs() 是 puts() 的文件操作版本，但是 fputs() 不会自动在末尾输出一个 '\n'

```c
char ch[]="hello world";
fputs(ch,stdout);
```

#### 7.4、字符串的长度

1）strlen() 函数：计算指定字符串 s 的长度，不包含字符串结束符 '\0'

```c
#include <string.h>
size_t strlen(const char *s);
```

* 参数：s，字符串首地址
* 返回值：字符串 s 的长度，size_t 为 unsigned int 类型

```c
//计算字符串有效长度
char ch[100]="hello world";
printf("数组大小：%d",sizeof(ch));		//100
printf("字符串大小：%d",strlen(ch));		//11

char ch1[]="hello world";
printf("数组大小：%d",sizeof(ch1));		//12
printf("字符串大小：%d",strlen(ch1));		//11
```

```c
char ch1[]="hello world";
int len=0;

while(ch[len]!='\0')
{
	len++;
}
printf("字符串的长度：%d"，len);
```

## 五、函数

### 1、概述

#### 1.1、函数分类

1）系统函数（库函数）

2）用户定义函数

#### 1.2、函数的作用

* 降低代码重复率
* 让程序更加模块化，利于阅读、修改和完善

#### 1.3、函数的调用：随机数

函数调用 5 要素：

* 头文件：包含指定的头文件
* 函数名字：函数名字必须与头文件声明的名字一样
* 功能：要知道函数实现的功能
* 参数：参数类型要匹配
* 返回值：根据需要接收返回值

```c
#include<time.h>
time_t time(time_t *t);
//功能：获取系统当前时间
//参数：常设置为NULL
//返回值：当前系统时间，time_t 相当于 long 类型，单位为毫秒

# include<stdlib.h>
void srand(unsigned int seed);
//功能：用来产生 rand() 函数产生随机数时的随机种子
//参数：如果每次 seed 相同，rand() 产生的随机数相同
//返回值：无

# include<stdlib.h>
int rand(void);
//功能：返回一个随机数
//参数：无
//返回值：随机数

```

```c
#include<time.h>
# include<stdlib.h>
# include<stddio.h>
//双色球	6个红球，1-32，不可重复		1个蓝球，1-16，可以和红球号码重复
int arr[7]={0};
srand((unsigned int)time(NULL));
int value=0;
int flag=0;
int j;
for(int i=0;i<6;i++)
{
	value=rand()%32+1;
    //去重
    for(j=0;j<flag;j++)
    {
        if(value==arr[j])
        {
            i--;
            break;
        } 
    }
    if(j==flag)
    {
        arr[flag]=value;
    	flag++;
    }
    
}
arr[7]=rand()%16+1;
```

### 2、函数的定义

#### 2.1、函数的定义格式

```c
返回类型 函数名(形式参数列表)
{
	函数体（数据定义部分，执行语句部分）
}
```

```c
//函数定义
int add(int a,int b)
{
    int sum=a+b;
    return sum;
}

int main()
{
    int a=10;
    int b=20;
    
    //函数调用
    int res=add(a,b);
    return 0;
}
```

* 在不同函数中的可以有相同的变量名，因为作用域不同；
* 在函数调用过程中，传递的参数称为实参（实际参数），有具体的值；
* 在函数定义过程中的参数称为形参（形式参数），只有类型，没有具体的值；
* 在函数调用过程中，将实参传递给形参；
* 在函数调用结束，函数相关的内存会在栈区自动销毁。

#### 2.2、函数名、形参、实参、返回值

1）函数名：见名知意

2）形参列表：在函数没有被调用时，形参不占用内存中的存储单元

* 在定义函数时指定的形参，可有可无，根据函数的需要来设计，如果没有形参，括号内为空，或者写一个 void 关键字

3）函数体：函数功能实现的过程

4）返回值：通过函数中的 return 语句获得，return 后面的值也可以是一个表达式

* 尽量保证 return 中的数据类型和函数的返回类型一致
* 如果函数返回的数据类型和函数返回类型不一致，则以函数返回类型为准，对于数值类型，会自动进行数据类型转换

### 3、函数的调用

#### 3.1、函数的执行流程

1）进入 main() 函数

2）调用自定义函数

3）自定义函数执行完，main() 会继续往下执行，直到执行 return 0，程序执行完毕

#### 3.2、函数的形参和实参

* 形参出现在函数定义中，在整个函数体中都可以使用，离开函数则不能使用；
* 实参出现在主调函数中，进入被调函数后，实参也不能使用；
* 实参变量对形参变量的数据传递是单向的值传递，只能由实参传递给形参，而不能由形参传递给实参；
* 再调用函数时，编译系统临时给形参分配存储单元。调用结束后，形参单元被释放；
* 形参与实参在内存中存放在不同的存储单元。在执行一个调用过程中，形参的值发生改变，不会影响实参的值。

```c
//字符串比较，相同返回0，不同返回 1 或者 -1
int strcmp(char ch1[],char ch2[])
{
    int i=0;
    while(ch1[i]==ch2[i])
    {
        //是否到字符串结尾
        if(ch1[i]=='\0')
        {
            return 0;
        }
        i++;
    }
    return ch1[i]>ch2[i]?1:-1;
}
```

### 4、函数样式

#### 4.1、无参函数

* 无参函数调用，直接函数名后跟括号即可

```c
//无参函数
void func1()
{
	printf("Hello\n");
}

int func2()
{
    return rand()%10;
}

int main()
{
    func1;
    srand((unsigned int)time(NULL));
    int randNum=func2();
    return 0;
}
```

#### 4.2、有参函数

1）如果实参列表包含多个实参，则各参数间用逗号隔开；

2）实参与形参应该个数相等，类型匹配（相同或者赋值类型兼容），按顺序对应；

3）实参可以是常量、变量、表达式，无论实参是何种类型的量，在进行函数的调用时，他们应该具有确定的值。

```c
//有参函数
//冒泡排序函数
void bubbleSort(int arr[],int len)
{
	for(int i=0;i<len-1;i++)
    {
        for(int j=0lj<len-1-i;j++)
        {
            if(arr[j]>arr[j+1])
            {
                int temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }
    }
    return;		//无返回值，return可写可不写
}

int main()
{
	int arr[]={9,1,7,4,2,10,3,8,6,5};
    bubbleSort(arr,sizeof(arr)/sizeof(arr[0]));
    return 0;
    
}
```

### 5、函数的返回值

* 如果函数定义没有返回值，函数调用时不能写 void 关键字，调用函数时也不能接收函数的返回值；
* void，空类型：void 类型不可以直接定义数据，但可以作为函数的返回值类型，表示没有返回值；

### 6、函数的声明

自定义函数三个过程：

* 函数声明；
* 函数定义；
* 函数调用

**当函数定义在主函数之前，可以直接定义，不比声明；但是当函数定义在主函数之后，就必须在主函数之前声明函数。**

```c
//函数声明
extern int add(int a,int b);
//在同一个文件中进行声明和定义，函数声明的时候可以省略 extern
int add(int a,int b);
//还可以省略形参的参数名
int add(int, int );

int main()
{
    //函数调用
    add(10,20);
	return 0;
}

//函数定义
int add(int a,int b)
{
    return a+b;
}
```

* 在一个程序中，函数只能定义一次，但是可以声明多次，调用多次；
* 函数声明时，可以省略形参的名称，只需要说明形参的类型即可。

### 7、主函数和 exit 函数

1）exit() 函数

* 功能：终止程序执行；
* 参数：整型，就是函数中止执行之后返回的错误码

```c
exit(0);
```

* 在主函数中，exit(0) 和 return 0 效果一样；但是在子函数中，调用 return 只是代表子函数中终止了，在子函数中调用 exit ，那么程序就终止了。

### 8、多文件编程

#### 8.1、分文件编程（多文件编程）

* 把函数声明放在头文件 xxx.h 中，在主函数中包含相应的头文件
* 在头文件对应的 xxx.c 中实现 xxx.h 声明的函数

01main.c

```c
#include<stdio.h>
#include"02func.h"

int main()
{
	int a = 10;
	int b = 20;
	int res = maxValue(a, b);
	printf("%d\n", res);
	return 0;
}
```

02func.c

```c
#include"02func.h"
//函数定义
int maxValue(int a, int b)
{
	return a > b ? a : b;
}
```

02func.h

```c
#pragma once	// 防止头文件重复包含
//#ifndef __02_FUNC_H__
//#define __02_FUNC_H__

//全局变量的定义		
//函数的声明
//extern int maxValue(int a, int b);
int maxValue(int a, int b);
//int maxValue(int,int);

```

#### 8.2、防止头文件重复包含

* 为避免同一个头文件被包含多次，C/C++中有两种方式：
    * #ifndef 方式；
    * #pragma 方式

## 六、指针

### 1、概述

#### 1.1、内存

* 存储器：用来存储程序，辅助CPU进行运算处理的重要部分
* 内存：内部存储器，暂存程序、数据，掉电丢失，SRAM，DRAM，DDR，DDR2，DDR3……
* 外存：外部存储器，长时间保存程序、数据，掉电不丢，ROM，ERROM，FLASH，硬盘，光盘……

内存是沟通CPU与硬盘的桥梁：

* 暂存方CPU的运算数据；
* 暂存与硬盘等外部存储器交换的数据。

#### 1.2、物理存储器和存储地址空间

存储地址空间：对存储器编码的范围

* 编码：对每个物理存储单元（一个字节）分配一个编号；
* 寻址：可以根据分配的号码找到相应的存储单元，完成数据的读写。

#### 1.2、内存地址

* 将内存抽象成一个很大的一维字符数组；
* 编码就是对内存的每一个字节分配一个32位或64位的编号；
* 这个内存编号我们称为内存地址；
* char：占一个字节，分配一个地址；
* int：占四个字节分配四个地址，通常使用首地址；
* float，struct，函数，数组等。

```c
//int a=10;
int a =0xaabbccdd;

printf("%p\n",&a);
getchar();
```

* 在 Windows 中，进行数据存储的时候，采用小端对齐

```c
int a=10;
//定义指针变量存储地址
int* p;
p=&a;

printf("%p\n",&a);
printf("%p\n",p);

// 通过指针 p 也可以间接改变变量 a 的值
*p=100;



//指针在内存中大小
//指针的大小：4字节（32位），8字节（64位）
printf("%d\n",sizeof(int*));

//指针类型应该和数据类型对应
char ch='a';
char* p1=&ch;

//指针大小：4字节（32位），8字节（64位）
printf("%d\n",sizeof(p1));

```

* 通过变量 a 可以改变值，通过指针 p 也可以间接改变变量的值；
* 指针类型：数据类型*
* 指针类型应该和数据类型对应
* &是取地址符号，是升维度的；*是取值符号，是降维度的

#### 1.3、指针大小

* 所有的指针类型存储的都是内存地址
* 指针大小：4字节（32位），8字节（64位）

```c
char ch='a';
int* p=&ch;
//上面的写法没问题，&ch和p存储的都是 ch 的地址
//但是此时 *p 无法取到 ch 的值
//也无法通过*p来修改值
*p=123456;

//在定义指针的时候，滋指针类型一定要和变量类型对应上
//例如，通过智者间接地改变变量的值，int* 指针是改变四个字节内存储的内容，而 char* 指针改变的是一个字节内存储的内容，会出错
```

#### 1.4、野指针和空指针

```c
//野指针：指针变量指向一个未知的空间（未定义的空间）
int *p=10;		//内存地址编号为100的内存地址赋值给 p
printf("%d\n",*p);		//这里会报错，可能是这个内存无法被访问
```

* 野指针：指针变量指向一个未知的空间（未定义的空间）
* 任意数值赋值给指针变量是没有意义的，这样的指针会成为野指针，因为这样的指针指向的内存是未知的
* 操作野指针对应的内存空间可能报错
* 操作系统将编号为 0-255 的内存作为系统占用，不允许访问操作
* 程序中允许存在野指针，但是操作野指针可能报错
* 不建议将一个变量的值直接赋值给指针
* C语言中，可以把 NULL 赋值给指针，标志此指针为空指针，不指向任何空间

```c
int* p=NULL;
//此时无法对p进行读写操作


//NULL 是一个值为 0 的宏常量
#define NULL ((void*)0)
```

* 空指针是指内存地址编号为 0 的内存空间
* 操作空指针对应的空间一定会报错
* 空指针可以用作条件判断

#### 1.5、万能指针 void*

* void* 指针可以指向任意类型变量的内存空间

```c
void* p=NULL;

int a=10;
p=(void*)&a;	//指向变量时，最好转换为 void*

//使用指针变量指向的内存时，转换为 int*
*((int*)p)=11;
```

* 万能指针可以接收任意类型变量的内存地址
* 在通过万能指针修改变量的值的时候，需要将其转换为变量类型对应的指针类型才可以进行修改

#### 1.5、const 修饰的指针类型

```c
//常量
const int a=10;
a=100;		//在这里修改不了

int *p=&a;
*p=100;		//但是可以通过指针间接修改常量的值
```

1）const 修饰指针类型（只读指针）

* 可以修改指针变量 p 的值
* 不可以修改指针指向内存空间的值

```c
int  a=10;
int b=20;
// const 修饰指针类型
const int* p=&a;

p=&b;		//可以修改指针变量 p 的值

*p=100;		//err，不可以修改指针指向内存空间的值

```

2）const 修饰指针变量

* 不可以修改指针变量 p 的值
* 可以修改指针指向内存空间的值

```c
int  a=10;
int b=20;
//const 修饰指针变量的值
int* const p=&a;

p=&b;		//err，不可以修改指针变量 p 的值
*p=200;		//可以修改指针指向内存空间的值
```

3）const 修饰指针类型和指针变量

```c
int a=10;
int b=20;
//const 修饰指针类型和指针变量
const int* const p=&a;

p=&b;		//err，不可以修改指针变量 p 的值
*p=100；		//err，不可以修改指针指向内存空间的值
    
//二级指针的操作
int** pp=&p;
//*pp是一级指针的值
*pp=&b;		//这样就可以修改指针变量p的值了

**pp==100;		//这样就可以修改变量的值了（指针指向内存空间的值）
```

* 不可以修改指针变量 p 的值
* 不可以修改指针指向内存空间的值
* **但是，可以通过二级指针对指针变量 p 和指针指向内存空间的值进行修改**

### 2、指针和数组

#### 2.1、数组名

* 数组名是数组的首元素地址，是一个常量。

```c
//指针和数组
int arr[]={1,2,3,4,5,6,7,8,'a','b','c'};

arr=100;	//err，数组名是一个常量，不允许赋值

//数组名数数组首元素地址
int* p;		//指向数组的指针
p=arr;
printf("%p\n",p);
printf("%p\n",arr);

for(int i=0;i<10;i++)
{
    //下面几种写法等价，都可以达到访问数组元素的目的
    printf("%d\n",arr[i]);
    printf("%d\n",p[i]);
    printf("%p\n",*(arr+i));
    printf("%p\n",*(p+i));
    printf("%p\n",*p);
}

//两个指针相减，得到的结果是两个指针的偏移量
int step=p-arr;
printf("%d\n",step);		// 10

printf("%d\n",sizeof(p));	//4
printf("%d\n",sizeof(arr));		//40
```

#### 2.2、指针加减运算

* 指针变量 +1，等同于内存地址+sizeof(数据类型)
* 两个指针相减，得到的结果是两个指针的偏移量
* 所有类型的指针相减，结果都是整型数据，表示偏移的该类型的数据的个数
* 指向数组的指针操作数组：
    * 方法一：p[i]
    * 方法二：*(p+i)

* 指向数组的指针 p 和数组名的区别：
    * p 是变量，arr 是常量
    * 在上面的代码中：sizeof(p)=4，sizeof(arr)=40


**数组在作为函数参数时，会退化为指针，丢失了数组的精度（数组的元素个数信息）**

```c
void BubbleSort(int *arr,int len)
{
	for(int i=0;i<len-1;i++)
    {
        for(int j=0;j<len-1-i;j++)
        {
            if(*(arr+j)>*(arr+j+1))
            {
                int temp=*(arr+j);
                *(arr+j)=*(arr+j+1);
                *(arr+j+1)=temp;
            }
        }
    }
}
```

1）字符串拷贝：

```c
//下面几个 函数功能相同
void myStrCopy01(char* dest,char* ch)
{
    int i=0;
    while(ch[i])
    {
        dest[i]=ch[i];
        i++;
    }
    dest[i]=0;
}

void meStrCopy02(char* dest,char* ch)
{
    int i=0;
    while(*(ch+i))
    {
        *(dest+i)=*(ch+i);
        i++;
    }
    *(dest+i)=0;
}

void myStrCopy03(char* dest,char* ch)
{
    while(*ch)
    {
        *dest=*ch;
    	dest++;		//指针 +1，相当于指向数组下一个元素，内存地址变化了sizeof(数据类型)
    	ch++;
    }
    *dest=0;
}

void myStrCopy04(char* dest,char* ch)
{
    while(*dest++=*ch++);		
}

//字符串拷贝
char ch[]="hello world";
char dest[100];
myStrCopy(dest,ch);
printf("%s\n",dest);
```

2）指针加减：

```c
int arr[]={1,2,3,4,5,6,7,8,9,10};
int *p=arr;

arr[-1];	//err，数组下标越界
p=&arr[3];

//指针操作数组时，允许下标为负数
printf("%d\n",p[-2]);		//相当于是 *(p-2)

/*
p--;		//指针的加减运算和指针的类型有关
p--;
p--;		//此时p和arr代表的地址一样了
*/

int step=p-arr;		//step=3

```

3）指针和运算符的操作

* 乘、除、取余不能用于指针的运算
* 指针指针不可以直接相加
* 指针之间可以进行比较运算：>, >=, <, <=, ==, !=
* 指针可以进行逻辑判断：逻辑与、逻辑或

```c
int arr[]={1,2,3,4,5,6,7,8,9,10};
int *p=arr;

p=&arr[3];
if(p>arr)
{
    printf("真\n");
}

if(p&&arr)
{
    
}

p=p+arr;	//err，两个指针相加结果为野指针
p=p*arr;	//err
p=p*4;		//err
p=p/arr;	//err
```

### 3、指针数组

* 指针数组，是数组，数组的每个元素都是指针类型
* 数组指针，指向数组的指针（实际上应该没有这种提法）
* 指针数组对应于二级指针

```c
int a=10;
int b=20;
int c=30;

//定义指针数组
int* arr[3]={&a,&b,&c};
for(int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
{
    printf("%d\n",*arr[i]);
}

//sizeof(arr)	12
//sizeof(arr[0])	4

//指针数组里面的元素存储的都是指针
int a[]={1,2,3};
int b[]={4,5,6};
int c[]={7,8,9};

int* arr[]={a,b,c};

for(int i=0;i<3;i++)
{
    printf("%d\n",*arr[i]);		//输出的是：1	4	7
}

//下面三个语句的输出结果是一样的
printf("%p\n",arr[0]);
printf("%p\n",a);
printf("%p\n",&a[0]);


//指针数组是一个特殊的二维数组模型
printf("%d\n",arr[0][1]);		//输出的是a[1], 也就是2


for(int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
{
    for(int j=0;j<3;j++)
    {
        //二维数组形式打印出来
        printf("%d\n",arr[i][j]);
        
        //指针偏移量形式打印出来
        printf("%d\n",*(arr[i]+j));
        
        //arr是指针数组的首地址
        printf("%d\n",*(*(arr+i)+j));		//指针数组对应于二级指针
    }
}


```

### 4、多级指针

* 一级指针最常用
* 二级指针就是指向一个一级指针变量地址的指针
* 三级指针使用的比较少

```c
//指针数组和二级指针建立关系
int a[]={1,2,3};
int b[]={4,5,6};
int c[]={7,8,9};

int* arr[]={a,b,c};

int** p=arr;

printf("%d\n",**p);		//1
//二级指针加偏移量，相当于跳过了一个一维数组
printf("%d\n",**(p+1));		//4
//一级指针加偏移量，相当于跳过了一个元素
printf("%d\n",*(*p+1));		//2

printf("%d\n",*(*(p+1)+1));		//2

for(int i=0;i<3;i++)
{
    for(int j=0;j<3;j++)
    {
        //下面单个作用是一样的
        printf("%d ",p[i][j]);
        printf("%d ",*(p[i]+j));
        printf("%d ",*(*(p+i)+j));
    }
    puts("");
}


```

```c
int a=10;
int b=20;
int* p=&a;
int** pp=&p;
//pp 二级指针变量的值
//*pp 一级指针的值
//**pp 变量的值

// pp=100;		野指针
*pp=&b;		//相当于 p=&b，间接改变了 p 的值
printf("%d\n",*p);		//20

**pp=100;		//间接改变 b 的值
*pp=100;	//err 野指针

//三级指针
int*** ppp=&pp;		//*ppp==pp=&p		//**ppp==*pp==p==&a		***ppp==**pp==*p==a



```

### 5、指针和函数

#### 5.1、值传递和引用传递

1）值传递

```c
void swap(int a,int b)
{
    int temp=a;
    a=b;
    b=temp;
}

int a=10;
int b=20;
//值传递，形参不影响喜实参的值
swap(a,b);
printf("%d %d\n",a,b);		//10 20

```

2）指针作为函数参数（地址传递）

```c
//指针作为函数参数
void swap(int* a,int* b)
{
    int temp=*a;
    *a=*b;
    *b=temp;
}

int a=10;
int b=20;
//地址传递，形参可以改变实参的值
swap(&a,&b);
printf("%d %d\n",a,b);		//20 10

```

#### 5.2、数组名作为函数参数

* 数组名作函数参数，函数的形参会退化为指针

1）数组名作函数参数（数组写法）

```c
void myStrCat(char* ch1,char* ch2)
{
    int i=0;
    while(ch1[i++]);		//相当于i=strlen(ch1)
    int j=0;
    while(ch2[j])
    {
        ch1[i+j]=ch2[j];
        j++;
    }
}

char ch1[100]="Hello";
char ch2[]="world";
myStrCat(ch1,ch2);

```

2）数组名作函数参数（指针写法）

```c
void myStrCat(char* ch1,char* ch2)
{
    int i=0;
    while(*(ch1+i)!='\0')		//相当于i=strlen(ch1)
    {
        i++
    }
    int j=0;
    while(*(ch2+j))
    {
        *(ch1+i+j)=*(ch2+j);
        j++;
    }
}

char ch1[100]="Hello";
char ch2[]="world";
myStrCat(ch1,ch2);
```

3）数组名作函数参数（指针写法）

```c
void myStrCat(char* ch1,char* ch2)
{
    while(*ch1)		//相当于i=strlen(ch1)
    {
        ch1++;
    }
    while(ch2)
    {
       *ch1=*ch2;
        ch1++;
        ch2++;
    }
}

//myStrCat1作用和myStrCat一样
void myStrCat1(char* ch1,char* ch2)
{
    while(*ch1) ch1++;
    while(*ch1++=*ch2++);
}

char ch1[100]="Hello";
char ch2[]="world";
myStrCat(ch1,ch2);
```

#### 5.3、字符串去空格

1）使用辅助空间

```c
//去字符串空格
void removeSpace(char* ch)
{
    char str[100]={0};
    char* temp=str;
    int i=0;
    int j=0;
    while(ch[i])
    {
        if(ch[i]!=' ')
        {
            str[j]=str[i];
            j++
        }
        i++;
    }
    while(*ch++==*temp++);
}

char ch[]="h  e ll o   w";
removeSpace(ch);
```

2）不使用辅助空间

```c
//去字符串空格
void removeSpace(char* ch)
{
    int i=0;
    int j=0;
    while(ch[i])
    {
        if(ch[i]!=' ')
        {
            ch[j]=ch[i];
            j++;
        }
        i++;
    }
    ch[j]=0;
}

char ch[]="h  e ll o   w";
removeSpace(ch);
```

#### 5.4、指针作为函数的返回值

1）数组形式

```c
char* myChr(char* str,char ch)
{
    int i=0;
    while(str[i])
    {
        if(str[i]==ch)
        {
            return &str[i];
        }
        i++;
    }
    return NULL;
}

char ch[]="hello world";
char* res=myChr(ch,l);
if(!res)
    printf("未找到\n");
```

2）指针形式

```c
char* myChr(char* str,char ch)
{
    while(*str)
    {
        if(*str==ch)
        {
            return &str;
        }
        str++;
    }
    return NULL;
}

char ch[]="hello world";
char* res=myChr(ch,l);
if(!res)
    printf("未找到\n");
else
    printf("%s\n",res);
```

#### 5.5、字符串查找字符串

```c
char* myStrStr(char* src,char* dest)
{
    char* fsrc=src;		//遍历源字符串的指针
    char* rsrc=src;		//记录每次相同字符串首地址
    char* tdest=dest;
    while(*fsrc)
    {
        rsrc=fsrc;
        while(*fsrc=*tdest&&*fsrc!='\0')
        {
            fsrc++;
            tdest++;
        }
        if(*tdest=='\0')
            return rsrc;
        else		//回滚
        {
            //目标字符串回滚
            tdest=dest;
            fsrc=rsrc;
            fsrc++;
        }
    }
    return NULL;
}

char src[]="hello world";
char dest[]="llo";
char* res=myChr(src,dest);
if(res==NULL)
{
    printf("未找到\n");
}
else
{
    printf("%s\n",res);
}
```

### 6、指针和字符串

#### 6.1、字符指针

1）常量字符串

```c
char ch[]="hello world";
char* p=ch;
printf("%s\n",p);

// char* p="hello world";		也是合法的，可以把p当做字符数组使用
/* 但是他们存在不同之处：
1)字符数组可以修改数组元素
2）无法通过 p[i]='m' 这样的方式修改内容
*/

char* p="hello world";
char* p1="hello world";		//p 和 p1 是相同的地址

```

* **char* p="hello world";		也是合法的，可以把p当做字符数组使用**
    但是他们存在不同之处：
    1）字符数组可以修改数组元素
    2）无法通过 p[i]='m' 这样的方式修改内容

    3）char ch[]="hello world"，是栈区字符串

    ​	char* p="hello world"，是数据区常量字符串，只读的

2）字符串数组

```c
//字符串数组
//指针数组
char ch1[]="hello";
char ch2[]="world";
char ch3[]="dabaobeier";
char* arr1[]={ch1,ch2,ch3};		

char* arr2[]={"hello","world","dabaobeier"};		//字符串数组，内容不可修改
for(int i=0;i<3;i++)
{
    printf("%s\n",arr2[i]);
}

//字符串排序
for(int i=0;i<3-1;i++)
{
    for(int j=0;j<3-1-i;j++)
    {
        if(arr2[j][0]>arr[j+1][0])		//首字符进行比较
        {
            //交换字符串
            char* temp=arr2[j];
            arr2[j]=arr2[j+1];
            arr2[j+1]=temp;
        }
    }
}

for(int i=0;i<3;i++)
{
    printf("%s\n",arr2[i]);
}
```

#### 6.2、字符指针作为函数参数

* 当作为函数的指针所指向的内容在函数内不需要被修改时，可以使用 const 修饰指针参数：

    **int myStrLen(const char* ch)**

```c
//数组实现
int myStrLen(char* ch)
{
    int i=0;
    while(ch[i])
        i++；
    return i;
}

//指针实现
int myStrLen(const char* ch)	//在函数中，不希望指针指向的内容被修改，若被修改会报错，从而保护不希望被修改的参数
{
    char* temp=ch;
    while(*temp)	temp++;
    return temp-ch;
}

char ch[]="hello world";
int lengthCh=myStrLen(ch);		//11
```

#### 6.3、const 修饰的指针变量

* **const 修饰的总是离它最近的内容**

1）通过一级指针修改变量的值

```c
const int a=10;
a=100;		//err
int* p=&a;
*p=100;		//通过一级指针修改变量的值
```

2）指向常量的指针

* 指向常量的指针，可以修改指针变量的值，不能修改指针变量指向内存空间的值

```c
char ch1[]="hello";
char ch2[]="world";

const char* p=ch1;

*p='m';		//err
p[2]='m';	//err，等同于 *(p+2)=m
p=ch2;		//没问题

```

3）常量指针

* 常量指针，可以修改指针变量指向内存空间的值，不可以修改针变量的值

```c
char ch1[]="hello";
char ch2[]="world";

//常量指针
char* const p=ch1;

p=ch2;	//err，常量指针不可以修改
p[2]='m';	//没问题
*(p+2)='m';		//没问题
```

4）只读指针

* 只读指针，不可以修改指针变量指向内存空间的值，不可以修改针变量的值
* 只读指针，可以通过二级指针修改只读指针指向的内存空间的内容
* 只读指针，可以通过二级指针修改只读指针指向的内存空间
* 由此可见，通过 const 修饰也并不是安全的，可以通过高级指针进行修改

```c
char ch1[]="hello";
char ch2[]="world";

const char* const p=ch1;
p=ch2;		//err
*p='m';		//err
p[2]="m";	//err

char** pp=&p;
*(*pp+1)='m';	//可以通过二级指针修改只读指针指向的内存空间的内容
*pp=ch2;	//可以通过二级指针修改只读指针指向的内存空间

//由此可见，通过 const 修饰也并不是安全的，可以通过高级指针进行修改
```

#### 6.4、主函数参数

```c
int main(int argc,char* argv[]);
```

* main 函数是由操作系统调用的，第一个参数 argc 标明 argv 数组的成员数量，argv 数组的每个成员都是 char* 类型；
* argv 是命令行参数的字符串数组
* argc 代表命令行参数的数量，程序名字本身算一个参数。

```c
//主函数的形参
//gcc -o hello.out hello.c	4个参数：gcc，-o,hello.out，hello.c 
//int argc	传递参数的个数
//char* argv[]	参数：char* argv[]={"gcc","-o","hello.out","hello.c"}，表示参数的具体内容
int main(int argc,char* argv[])
{
    //参数个数判断
    if(argc<3)
    {
        printf("缺少参数\n");	//在命令行运行程序时，若参数个数不一致，会报错
        return -1;
    }
	for(int i=0;i<argc;i++)
    {
        printf("%s\n",argv[i]);			
    }
    return 0;
}
```

#### 6.5、字符串中某个字符串出现的次数

1）while 模型

```c
char* myStrStr(char* src,char* dest)
{
    char* fsrc=src;		//遍历源字符串的指针
    char* rsrc=src;		//记录每次相同字符串首地址
    char* tdest=dest;
    while(*fsrc)
    {
        rsrc=fsrc;
        while(*fsrc=*tdest&&*fsrc!='\0')
        {
            fsrc++;
            tdest++;
        }
        if(*tdest=='\0')
            return rsrc;
        else		//回滚
        {
            //目标字符串回滚
            tdest=dest;
            fsrc=rsrc;
            fsrc++;
        }
    }
    return NULL;
}

char *str="hello world";
char ch[]="llo";
char* p=myStrStr(str,ch);
int cnt=0;		//记录出现的次数
while(p)
{
    cut++;
    p=p+strlen(ch);
    p=myStrStr(p,ch);
}

printf("%s 在 %s 中出现的次数：%d\n",ch,str,cnt);

```

2）do-while 模型

```c
char* myStrStr(char* src,char* dest)
{
    char* fsrc=src;		//遍历源字符串的指针
    char* rsrc=src;		//记录每次相同字符串首地址
    char* tdest=dest;
    while(*fsrc)
    {
        rsrc=fsrc;
        while(*fsrc=*tdest&&*fsrc!='\0')
        {
            fsrc++;
            tdest++;
        }
        if(*tdest=='\0')
            return rsrc;
        else		//回滚
        {
            //目标字符串回滚
            tdest=dest;
            fsrc=rsrc;
            fsrc++;
        }
    }
    return NULL;
}

char *str="hello world";
char ch[]="llo";
char* p=myStrStr(str,ch);
int cnt=0;		//记录出现的次数
do
{
    if(p)
    {
        cut++;
        p+=strlen(ch);
        p=myStrStr(p,ch);
    }
}while(p);

printf("%s 在 %s 中出现的次数：%d\n",ch,str,cnt);

```

#### 6.6、统计非空格字符个数

1）数组格式

```c
int getStrCnt(char* ch)
{
    int i=0;
    int cnt=0;
    while(ch[i])
    {
        if(ch[i]!=' ')
            cnt++;
        i++;
    }
    return cnt;
}

char ch[]="h  e l  lo  wo   rld ";
int res=getStrCnt(ch);

```

2）指针格式

```c
int getStrCnt(char* ch)
{
    int cnt=0;
    while(*ch)
    {
        if(*ch!=' ')
            cnt++;
        ch++;
    }
    return cnt;
}

char ch[]="h  e l  lo  wo   rld ";
int res=getStrCnt(ch);

```

3）统计各个字符出现的次数

```c
//hash表
char ch[]="h  e l  lo  wo   rld nichousha chounizadi zaichuyigeshishi";
int hash[27]={0};
while(*ch)
{
    if(*ch==' ')
    {
        hash[26]++;
    }
    else
    {
        hash[*ch-'a']++;
    }
    ch++;
}

printf("空格出现了 %d 次\n",hash[26]);
for(int i=0;i<26;i++)
{
    printf("字符 %c 出现的次数为 %d\n",i+'a',hash[i]);
}

```

### 7、常用的字符串操作

#### 7.1、字符串逆置

1）数组形式

```c
void inverse(char* ch)
{
    int i=0;
    int j=strlen(ch)-1;
    while(i<j)
    {
        char temp=ch[i];
        ch[i]=ch[j];
        ch[j]=temp;
        i++;
        j--;
    }
}


//字符串逆置
char ch[]="hello world";
inverse(ch);

```

2）指针形式

```c
void inverse(char* ch)
{
    char* ftemp=ch;
    char* btemp=ch+srtlen(ch)-1;
    while(ftemp<btemp)
    {
        char temp=*ftemp;
        *ftemp=*btemp;
        *btemp=*ftemp;
        ftemp++;
        btemp--;
    }
}


//字符串逆置
char ch[]="hello world";
inverse(ch);

```

#### 7.2、字符串拷贝

1）strcopy()

```c
#include<string.h>
char* strcopy(char* dest,const char* rsc);
```

* 功能：把 src 所指向的字符串复制到 dest 所指向的空间，'\0' 也会拷贝过去
* 参数：
    * dest：目的字符串首地址
    * src：源字符串首地址
* 返回值：
    * 成功：返回 dest 字符串的首地址
    * 失败：NULL

**注：如果 dest 所指向的内存空间不够大，可能会造成缓冲溢出的错误** 

```c
#include<string.h>
char ch[]="hello world";
char str[100];
strcopy(str,ch);
```

strcpy()

```c
void myStrCpy(char* dest,const char* src)
{
	while(*dest++=*src++);
}
```

2）strncopy()

```c
#include<string.h>
char* strncopy(char* dest,const char* src,size_t n);
```

* 功能：把 src 所指向的字符串的前 n 个字符复制到 dest 所指向的空间，'是否拷贝结束符取决于指定的长度是否包含结束符
* 参数：
    * dest：目的字符串首地址
    * src：源字符串首地址
    * n：指定需要拷贝字符个数
* 返回值：
    * 成功：返回 dest 字符串的首地址
    * 失败：NULL

**注：当指定长度不包括字符串结束符时， dest 内不包含结束符，如果直接打印 dest 会出现越界现象** 

```c
//字符串有限拷贝
#include<string.h>
char ch[]="hello world";
char str[100];
strcopy(str,ch，5);
```



#### 7.3、字符串追加

1）strcat()

```c
#include<string.h>
char* strcat(char* dest, const char* src);
```

* 功能：把 src 字符串连接到 dest 的尾部，'\0'也会追加过去
* 参数：
    * dest：目的字符串首地址
    * src：源字符串首地址
* 返回值：
    * 成功：返回 dest 字符串的首地址
    * 失败：返回 NULL

**注：如果 dest 所指向的内存空间不够大，可能会造成缓冲溢出的错误** 

```c
#include<string.h>
char* ch[]="hello";
char* src[]="world";

strcat(ch,src);
```

```c
void myStrCat(char* dest,const char* src)
{
    while(*dest++);
    while(*dest++=*src++);
}
```



2）strncat()

```c
#include<string.h>
char* strcat(char* dest, const char* src,size_t n);
```

* 功能：把 src 字符串连接到 dest 的尾部，'\0'也会追加过去
* 参数：
    * dest：目的字符串首地址
    * src：源字符串首地址
    * n：指定需要追加字符的个数
* 返回值：
    * 成功：返回 dest 字符串的首地址
    * 失败：返回 NULL

**注：如果 dest 所指向的内存空间不够大，可能会造成缓冲溢出的错误** 

**如果指定长度大于源字符串的长度，会将整个源字符串追加过去，不会报错**

```c
#include<string.h>
char* ch[]="hello";
char* src[]="world";

strncat(ch,src,n);
```

```c
void myStrCat(char* dest,const char* src)
{
    while(*dest++);
    while(*dest++=*src++&&n--);
}
```



#### 7.4、字符串比较

1）strcmp()

```c
#include<string.h>
int strcmp(const char* s1,const char* s2);
```

* 功能：比较 s1 和 s2 的大小，比较的是字符 ASCII 码的大小
* 参数：
    * s1：字符串1的首地址
    * s2：字符串2的首地址
* 返回值：
    * 相等：0
    * 大于：>0
    * 小于：<0

**不相等的时候，有的操作系统返回 ASCII 码的差值，有的操作系统返回1 或者 -1** 

```c
//字符串比较
#include<string.h>
char ch1[]="hello";
char ch2[]="world";

int value=strcmp(ch1,ch2);
```

2）strncmp()

```c
#include<string.h>
int strncmp(const char* s1,const char* s2,size_t n);
```

* 功能：比较 s1 和 s2 前 n 个字符的大小，比较的是字符 ASCII 码的大小
* 参数：
    * s1：字符串1的首地址
    * s2：字符串2的首地址
    * n：指定比较字符的数量
* 返回值：
    * 相等：0
    * 大于：>0
    * 小于：<0

**不相等的时候，有的操作系统返回 ASCII 码的差值，有的操作系统返回1 或者 -1** 

```c
//字符串比较
#include<string.h>
char ch1[]="hello";
char ch2[]="world";

int value=strcmp(ch1,ch2,5);
```

```c
int myStrCmp(const char* s1,const char* s2)
{
    while(*s1==*s2)
    {
        if(!*s1)
            return 0;
        s1++;
        s2++;
    }
    return *s1>*s2?1:-1;
}
```

```c
//这个版本不如上面的版本明朗
int myStrCmp(const char* s1,const char* s2)
{
    while(*s1++==*s2++ && !*s1)
    {
        if(!*--s1 && !*--s2)
            return 0;
    }
    return *s1>*s2?1:-1;
}
```

```c
int myNStrCmp(const char* s1,const char* s2,size_t n)
{
    for(int i=0;i<n && s1[i] && s2[i];i++)
    {
        if(s1[i]!=s2[i])
        {
            return s1[i]>s2[i]?1:-1;
        }
    }
}
```



#### 7.5、字符串格式化

1）sprintf() ：格式化输出

```c
#include<stdio.h>
int sprintf(char* str,const char* format,...);
```

* 功能：根据参数 format 来转换并格式化数据，然后将结果 str 输出到指定的空间中，直到出现字符串结束符为止。**实际就是将format 的内容存放到 str 中，并输出** 
* 参数：
    * str：字符串首地址
    * format：字符串格式，用法与 printf 相同
* 返回值：
    * 成功：实际格式化的字符个数
    * 失败：-1

**注：format 也可以使用各种格式控制** 

```c
#include<stdio.h>
char ch[100];
char ch2[100];
sprintf(ch，"hello world");		//输出：hello world
printf("%s\n",ch);				//输出：hello world

//format 也可以使用各种格式控制
sprintf(ch2,"%d+%d=%d\n",1,2,3);	//输出：1+1=2
printf("%s\n",ch1);					//输出：1+1=2
```

2）sscanf()：格式化读入

```c
#include<stdio.h>
int sscanf(const char* str,const char* format,...);
```

* 功能：从 str 指定的字符串读取数据，并根据参数 format 字符串的格式来进行格式转换并格式化数据。**实际就是将 str 按照 format 的格式进行格式转化** 
* 参数：
    * str：指定的字符串首地址
    * format：字符串样式，用法和 sacnf 相同
* 返回值：
    * 成功：参数数目，成功转换的值的个数
    * 失败：-1

```c
char ch[]="1+2=3";
int a,b,c;
sscanf(ch,"%d+%d=%d",&a,&b,&c);		//把 ch 按照 "%d+%d=%d",&a,&b,&c 的格式分别存入 a、b、c 中

printf("%d\n",a);		//1
printf("%d\n",b);		//2
printf("%d\n",c);		//3
```

```c
char ch[]="hello world";
char str[100];
char str1[100];

sscanf(ch,"%s",str);	//把 ch 中的内容按照字符串的格式读取到 ch 中，实际读取到的是 hello
printf("%s\n",str);		//输出：hello

sscanf(ch,"%[^\n]s",str1);	//把 ch 中的内容按照字符串的格式读取到 ch 中，实际读取到的是 hello world
printf("%s\n",str1);		//输出：hello world

char ch1[]="helloworld";
char str2[100];

sscanf(ch1,"%5s",str2);	//把 ch 中的前五个字符按照字符串的格式读取到 ch 中，实际读取到的是 hello
printf("%s\n",str2);		//输出：hello

char ch1[]="helloworld";
char str2[100];
char str3[100];

sscanf(ch1,"%5s%s",str2,str3);	
printf("%s\n",str2);		//输出：hello
printf("%s\n",str3);		//输出：world
```



#### 7.6、字符串查找

1）strchr()

```c
#include<string.h>
char* strchr(const char* s,int c);
```

* 功能：在字符串 s 中查找字符 c 出现的位置
* 参数：
    * s：字符串首地址
    * c：匹配字符
* 返回值：
    * 成功：返回第一次出现 c 的地址
    * 失败：NULL

```c
char* strchr(const char* ch,int c)
{
    while(*ch)
    {
        if(*ch==c)
            return ch;
        ch++;
    }
    return NULL;
}

char ch[]="hello world";
char c='l';
char* p=strchr(ch,c);

printf("%s\n",p);
```



2）strstr()

```c
#include<string.h>
char* strstr(const char* haystack,const char* needle);
```

* 功能：在字符串 haystack 中查找字符串 needle 出现的位置
* 参数：
    * haystack：源字符串的首地址
    * needle：匹配字符串的地址
* 返回值：
    * 成功：返回第一次出现 needle 的地址
    * 失败：NULL

```c
char ch[]="hello world";
char str[]="llo";
char* p=strstr(ch,str);
printf("%s\n",p);
```



#### 7.7、字符串分割

1）strtok()

```c
#include<string.h>
char* strtok(char* str,const char* delim);
```

* 功能：将字符串分割成一个个片段，当 strtok() 在参数 str 的字符串中发现参数 delim 中包含的分割字符时，则会将该字符改为 0 字符，当连续出现多个时，只替换第一个为 0
* 参数：
    * str：指向欲分割的字符串
    * delim：为分割字符串中包含的所有字符
* 返回值：
    * 成功：分割后字符串首地址
    * 失败：NULL

**在第一次调用时，strtok() 必须基于参数 str 字符串**

**在往后的调用，则将参数 str 设置成 NULL，每次调用成功则返回指向被分割出片段的指针** 

```c
char ch[]="www.baidu.com";

//第一次截取
char* p=strtok(ch,".");
printf("%s\n",p);		//输出：www
printf("%s\n",ch);		//输出：www	此时 ch 中的内容为：www\0baidu.com

printf("%p\n",p);		//输出：0019F7E4
printf("%p\n",ch);		//输出：0019F7E4

//第二次截取
p=strtok(NULL,".");
printf("%s\n",p);		//输出：baidu	此时，ch 中的内容为：www\0baidu\0com

//第三次截取
p=strtok(NULL,".");
printf("%s\n",p);		//输出：com	
```

* strtok() 会破坏源字符串 str，用 \0 替换分割的标志位

```c
char ch[]="123456789@qq.com";
char chCopy[100]={0};

//字符串备份
strcopy(chCopy,ch);

char* p=strtok(str,"@");
printf("%s\n",p);		//输出：123456789

p=strtok(NULL,".");
printf("%s\n",p);		//输出：qq


```

```c
char* ch[]="nichousha\nchounizadi\nzaichouyixiashishi\nduibuqidagewocuole\nguawazi\n";
char*p=strtok(ch,"\n");
printf("%s\n",p);		//输出：nichousha

//利用循环多次截取
while(p)
{
    printf("%s\n",p);
    p=strtok(NULL,"\n");
}
/*
输出：
nichousha
chounizadi
zaichouyixiashishi
duibuqidagewocuole
guawazi
*/
```

#### 7.8、字符串类型转换

1）atoi()

```c
#include<stdlib.h>
int atoi(const char* nptr);
```

* 功能：atoi() 会扫描字符串，跳过前面的空格字符，直到遇到数字或者正负号才开始做转换，而遇到非数字或字符串结束符才结束转换，并将结果返回
* 参数：nptr，待转换的字符串
* 返回值：成功转换后的整数

**类似的函数：**

* atof()：把一个小数形式的字符串转换为一个浮点数（特指双精度浮点型）
* atol()：将一个字符串转换成 long 类型

```c
#include<stdlib.h>

/*
char ch[]="123456";

int i=atoi(ch);
printf("%d\n",i);		//输出：123456
*/

/*
char ch[]="-123456";

int i=atoi(ch);
printf("%d\n",i);		//输出：-123456
*/

/*
char ch[]="    -123456abc123";

int i=atoi(ch);
printf("%d\n",i);		//输出：-123456
*/

char ch[]="  asc   -123456abc123";

int i=atoi(ch);
printf("%d\n",i);		//输出：0


```

**注：只能识别十进制**

```c
char ch[]="   -123.456abc123";

int i=atof(ch);
printf("%f\n",i);		//输出：-123.456
```

```c
char ch[]="   -123.456abc123";

int i=atof(ch);
printf("%d\n",i);		//输出：-123
```

## 七、内存管理

### 1、作用域

C 语言变量的作用域主要有三种：

* 代码块作用域（代码块是 {} 之间的一段代码）
* 函数作用域
* 文件作用域

#### 1.1、局部变量

局部变量也叫 auto 自动变量（auto 可以不写），一般情况下代码块 {} 内部定义的变量都是自动变量，具有如下特点：

* 在一个函数内定义，只在函数范围内有效
* 在复合语句中定义，只在复合语句中有效
* 随着函数调用的结束或复合语句的结束，局部变量的生命周期也就结束了

```c
int  main()
{
    //定义变量，局部变量，只在main函数内有效
    //作用域：main函数之内
    //生命周期：从创建到函数结束
    auto int a=10;		//auto可以省略不写
    return 0;
}
```

#### 1.2、全局变量

* 在函数外定义，可被本文件及其他文件中的函数所共用，若其他文件中的函数调用此变量，须用 extern 声明
* 全局变量的生命周期和程序运行周期一样
* 不同文件的全局变量不可重名
* 全局变量存储在数据区
* 全局变量可以和局部变量同名，使用的时候采用就近原则
* 不同文件中的全局变量不可以重名

main.c

```c
#include<stdio.h>
//全局变量：在函数外部定义的变量
//作用域，整个项目中所有文件，如果在其他文件中使用，需要声明
//生命周期，从程序创建到程序销毁
int a=10;
void func()
{
    a=100;
    printf("%d\n",a);
}
int main()
{
    printf("%d\n",a);	//10
    int a=123;		//数据在操作时，采用就近原则
    
    //匿名内部函数
    {
        int a=456;
        printf("%d\n",a);		//456
    }
    
     //匿名内部函数
    {
        a=456;
        printf("%d\n",a);		//456
    }
    
    printf("%d\n",a);	//456
 
    func();				//100
    func2();			//1000
    return 0;
}
```

test.c

```c
#include<stdio.h>
//声明全局变量
extern int a;

//定义全局变量
int b=10;	//全局变量不可以重名
int b=10;	//err，全局变量不可以重名
void func2()
{
    a=1000;
    printf("%d\n",a);
}
```

#### 1.3、静态局部变量

* static 局部变量的作用域也是在定义的函数内有效
* static 局部变量的生命周期和程序的运行周期一样，同时 static 局部变量的值只能初始化一次，但可以赋值多次
* static 局部变量若未赋初值，则由系统自动赋值，数值型变量自动赋初值 0，字符型变量赋空字符
* static 局部变量只能在其作用域内使用，即当前函数中使用
* static 局部变量在数据区存储，不会随着栈区的变化而变化

```c
//静态局部变量
void func()
{
	printf("%d\n",b);	//err，未定义变量b
 
}
int main()
{
	//静态局部变量
    static int b=10;
    printf("%d\n",b);		//10
    return 0;
    
}
```

```c
//静态局部变量
void func()
{
   // printf("%d\n",b);	//err，未定义变量b
    
    static int b=10;		//静态局部变量只会初始化一次，可以多次赋值，作用域只在函数内，只能在当前函数中使用，生命周期与程序生命周期相同
    b++;
    printf("%d\n",b);
}

int main()
{
    //如果在 func() 中定义的是局部变量，会输出十次 11
    for(int i=0;i<10;i++)
    {
        func();		//十次输出，分别输出：11,12,13,14,15,16,17,18,19，20
    }
    return 0;
}
```

#### 1.4、静态全局变量

* 静态全局变量，作用域为本文件，只能在本文件中使用，不能在其他文件中使用
* 生命周期：从程序创建到程序销毁
* 存储在数据区

main.c

```c
//静态全局变量，作用域为本文件，只能在本文件中使用，不能在其他文件中使用
//生命周期：从程序创建到程序销毁
//存储在数据区
static int a=10;
void func()
{
    a=20;
     printf("%d\n",a);		//20
}
int main()
{
    printf("%d\n",a);		//10
    func();
    func06();
    return 0;
}
```

test.c

```c
extern int a;	//err，静态全局变量的作用域为本文件，因此这里无法使用
void func06()
{
	 printf("%d\n",a);		//20
}
```

* 变量作用域

|   变量类型   |      作用域      |         生命周期         | 存储位置 |
| :----------: | :--------------: | :----------------------: | :------: |
|   局部变量   |     函数内部     | 从局部变量创建到函数结束 |   栈区   |
|   全局变量   |  项目中所有文件  |   从程序创建到程序销毁   |  数据区  |
| 静态局部变量 |     函数内部     |   从程序创建到程序销毁   |  数据区  |
| 静态全局变量 | 定义所在的文件中 |   从程序创建到程序销毁   |  数据区  |

#### 1.5、未初始化的数据

* 局部变量未初始化，值为任意值（乱码）
* 未初始化的全局变量，值为0
* 未初始化的静态局部变量，值为0
* 未初始化的静态全局变量，值为0

```c
//未初始化的全局变量，值为0
int abc；
int main()
{
    /*
    //局部变量未初始化，值为任意值（乱码）
    int abc;
    printf("%d\n",abc);		//在 vs 中 err，在其他环境中可以输出，但是为乱码
    */
    printf("%d\n",abc);	
}
```

#### 1.6、全局函数和静态函数

* 在 C 语言中，函数默认都是全局的，使用 static 关键字可以使函数变成静态函数
* static 静态函数只能在定义这个函数的文件中使用，在其他文件中不能调用，即使在其他文件中声明这个函数也无法使用
* 对于不同文件的 static 函数的名字可以相同
* 在 C 语言中，不支持函数的重载
* 全局函数的名称在作用域中是惟一的
* 全局函数的作用域：在这各个项目的所有文件中都可以使用
* 函数可以调用自己：递归函数。递归函数一定要有出口
* 静态函数可以和全局函数重名，在当前文件中，使用的是当前文件中定义的函数
* 静态函数和全局函数的生命周期相同，从程序创建到程序销毁

main.c

```c
//全局函数声明
void buble();
int main()
{
    buble();	//err，静态函数，作用域仅限于定义这个函数的文件
    return 0;
}
```

test.c

```c
//静态函数，作用域仅限于定义这个函数的文件
static void buble()
{
    printf("buble\n");
}
```

* 函数作用域

| 函数类型 |     作用域     |       生命周期       |              存储位置              |
| :------: | :------------: | :------------------: | :--------------------------------: |
| 全局函数 | 项目中所有文件 | 从程序创建到程序销毁 | 代码区（未唤醒），栈区（唤醒之后） |
| 静态函数 | 定义所在的文件 | 从程序创建到程序销毁 |               代码区               |

#### 1.7、extern 全局变量声明

* extern 用于声明一个在别的文件中已经定义的全局变量，这里只是声明，不是定义

**注意：**

* 语序在不同的函数中使用相同的变量名，它们代表了不同的对象，分配不同的单眼，互不干扰
* 同一源文件中，允许全局变量和局部变量同名，在局部变量的作用域内，全局变量不起作用
* 所有的函数默认是全局的，那么函数名不能重名；不同文件的 static 函数是可以重名的

### 2、内存布局

#### 2.1、内存分区

* 局部常量不安全，全局常量是安全的

```c
//未初始化全局变量
int a1;

//初始化全局变量
int b1=10;

//未初始化静态全局变量
static int c1;

//初始化静态全局变量
static int d1=10;

int main()
{
    //初始化局部变量
    int e1=10;
    
    //未初始化静态局部变量
    static int f1;
    
    //初始化静态局部变量
    static int g1=10;
    
    //常量字符串
    char* p="hello world";
    
    //数组
    int arr[]={1,2,3,4};
    
    //指针变量
    int *pp=arr;
    //指针地址 &pp
    return 0;
}
```

#### 2.2、内存模型

**应用程序的内存四区模型：**

* 代码区：程序执行的二进制码（程序指令）
    * 共享的，形同内容只存放一份
    * 只读的
* 数据区（与程序同生共死）
    * 初始化数据区，data 段
    * 未初始化数据区，bss 段
    * 常量区
* 栈区：系统为每一个程序分配一个临时的空间，要用就分配，用完就销毁
    * 局部变量，函数信息，函数参数，数组
    * 栈区大小：1MB，在 windows 中可以拓展到 10MB，在 Linux 中，可以拓展到 16MB
* 堆区：
    * 堆区大小：没有上限限制
    * 存储大数据，图片，音频视频文件
    * 需要手动开辟，手动释放。开辟方式：malloc，colloc，realloc，free

#### 2.3、内存分区概述

* 在程序没有运行前，即程序没有加载到内存前，可执行程序内部已经分好了 3 段信息：代码区（text）、数据区（data）、未初始化数据区（bss），其中 data 和 bss 合起来统称静态区或者全局区。
* 程序在加载到内存前，代码区和全局区（data 段和 bss 区）的大小是固定的，程序运行期间是不能改变的。
* 运行可执行程序，系统把程序加载到内存，除了根据可执行程序的信息分出的代码区（text）、数据区（data）、未初始化数据区（bss）之外，还额外增加了栈区、堆区。
* 内存中，从低地址区到高地址区的方向，依次分别是：代码区、初始化数据区（离低地址区较近的部分是常量区，离高地址区较近的部分是 data 段）、未初始化数据区（bss）、堆区、栈区（栈区内部从高地址区往低地址区）。

**程序运行之前：** 

1）代码区

* 存放 CPU 执行的机器指令。
* 代码区通常是可共享的（即其他的可执行程序也可以调用它）。使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。
* 代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指令。
* 另外，代码区还规划了局部变量的相关信息。

2）全局初始化数据区 / 静态数据区（data 段）

* data 段包含了在程序中明确被初始化的全局变量、已经被初始化的静态变量（包括全局静态变量和局部静态变量）、常量数据（例如字符串常量）

3）未初始化数据区（bss 区）

* 存入的是全局未初始化变量和外初始化静态变量
* 未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者是空（NULL）

**程序运行之后：** 

1）代码区（text segment）

* 加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的

2）未初始化数据区（bss）

* 加载的是可执行文件 bss 段，位置可以分开亦可以紧靠数据段，存储在数据段的数据（全局未初始化、静态未初始化数据）的生存周期为整个程序运行过程

3）全局初始化数据区 / 静态数据区（data segment）

* 加载的是可执行文件的数据段，存储于数据段（全局初始化、静态初始化的数据，文字常量（只读））的数据的生存周期为整个程序运行过程

4）栈区（stack）

* 栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。
* 在程序运行过程中，实时加载和释放，因此局部变量的生存周期为申请到释放该段栈空间

5）堆区（heap）

* 堆是一个大容器，其容量远远大于栈，但没有栈那样先进后出的顺序。
* 用于动态内存分配。
* 堆在内存中位于 bss 区和栈区之间。
* 一般由程序员分配和释放，若程序员未释放，程序结束时由操作系统回收。

#### 2.4、栈区存储模型

1）普通变量存储：从高地址区往低地址区存储

2）数组：开辟一段连续的内存，数组从前往后是从低地址区往高地址区存储

3）栈区：从高地址区向低地址区生长。先进后出，后进先出

4）堆区：从低地址区向高地址区生长

### 3、堆空间开辟和使用

#### 3.1、栈区的大小

```c
int main()
{
    //栈区的大小
	int arr[820000]={0};	//err，数组太大了，栈区内存不够	820000*4/1024/1024>31MB，远大于栈区的大小，栈区大小为1MB
}

```

* 栈区的大小可以拓展，windows 中可以拓展至10 MB，在 Linux 中，可以拓展到 16MB

#### 3.2、开辟堆空间存储数据

1）malloc() 函数

```c
#include<srdlib.h>
void* malloc(size_t size);
```

* 功能：在内存的动态存储区（堆区）中分配一块长度为 size 字节的连续区域，用来存放类型说明符指定的类型，分配的内存空间内容不确定，需要使用 memset 进行初始化
* 参数：size，需要分配的内存大小（单位，字节）
* 返回值：
    * 成功：分配空间的起始地址
    * 失败：NULL

2）free() 函数

```c
#include<srdlib.h>
void free(void* ptr);
```

* 功能：释放 ptr 所指向的一块内存空间，ptr 是一个任意类型的指针变量，指向被释放区域的首地址，对同一内存空间多次释放会出错
* 参数：ptr，需要释放空间的首地址，被释放区应该是由 maclloc 函数所分配的区域
* 返回值：无

```c
int main()
{
	//开辟堆空间存储数据
    int* p=(int*)malloc(sizeof(int));
    printf("%p\n",p);
    printf("%d\n",*p);	//乱码
    
    //使用堆空间
    *p=123;
    printf("%d\n",*p);	//123
    
    //释放堆空间
    free(p);
    printf("%p\n",p);	//还是输出 p 的地址，但是此时 p 指向的是一个未知空间，p 为野指针
    *p=456;
    printf("%d\n",*p);	//456
    p=NULL;
    
    return 0;
}
```

**为了防止所使用的堆空间指针释放后成为野指针，应该让其指向空指针。** 

3）可以开辟多大的堆空间

* 理论上没有上限，不超过最大剩余内存即可。但是由于开辟的是连续空间，因此开辟空间过大，当内存不存在这么大的连续空间，会开辟失败。

#### 3.3、堆空间存储数据

* 在堆空间的开辟和释放的时候，应该保证释放的指针和开辟时的指针相同

```c
#define MAX 10

int* p=(int*)malloc(sizeof(int)*10);
for(int i=0;i<10;i++)
{
	p[i]=i;
}
for(int i=0;i<10;i++)
{
    printf("%d\n",*(p+i));
}
free(p);


srand((size_t)time(NULL));
int* p=(int*)malloc(sizeof(int)*MAX);
for(int i=0;i<MAX;i++)
{
    p[i]=rand()%100;
    printf("%d\n",*(p+i));
}

for(int i=0;i<MAX;i++)
{
    printf("%d\n",*p);
    p++;
}
free(p);	//err，这里会报错，因为指针在叠加过程中，正在不断改变，最后释放的指针和开辟的空间首地址不同，会导致前面开辟的堆空间成为无主空间，只有等程序结束才能释放
//在堆空间的开辟和释放的时候，应该保证释放的指针和开辟时的指针相同
```

#### 3.4、内存操作函数

1）memset()

```c
#include<string.h>
void* memset(void* s,int c,size_t,n);
```

* 功能：将 s 的内存区域的前 n 个字节以参数 c 填入
* 参数：
    * s：需要操作的内存的首地址
    * c：填充的字符，c 为 int 型，但必须是 unsigned char，范围为 0-255
    * n：指定需要设置的大小
* 返回值：s 的首地址

```c
int* p=(int*)malloc(sizeof(int)*10);
//未初始化时，原始数据，乱码
for(int i=0;i<10;i++)
{
    printf("%d\n",*(p+i));
}

//memset() 重置内存空间的值
memset(p,0,40);
//memset(p,1,40)，这样无法使内部每个整型都变成 1，实际上是将四十个字节分别设置为 00000001，最后再将 0000001000000100000010000001 以整型读出，就和预想的不一样了
//字符数组可以使用 memset() 重置，但是不能用于字符串形式输出
for(int i=0;i<10;i++)
{
    printf("%d\n",*(p+i));		//输出十个 0 
}

free(p);
```



2）memcpy()

```c
#include<string.h>
void* memcpy(void* dest,const void* src,size_t,n);
```

* 功能：拷贝 src 所指的内存内容的前 n 个字节到 dest 所指的内存地址上
* 参数：
    * dest：目的内存首地址
    * src：源内存首地址
    * n：需要拷贝的字节数
* 返回值：dest的首地址

**注：dest 和 src 所指的内存空间不可以重叠，否则可能会导致程序报错。当他们重叠的时候，使用 memmove** 

```c
int arr[]={1,2,3,4,5,6,7,8,9,10};
int* p=(int*)malloc(sizeof(int)*10);

memcpy(p,arr,sizeof(int)*10);
for(int i=0;i<10;i++)
{
    printf("%d\n",*(p+i));		//输出：1,2,3,4,5,6,7,8,9，10 
}

free(p);

//dest 和 src 所指的内存空间重叠，可能会导致报错
memcpy(&arr[5],&arr[3],20);
```

**strcpy() 和 memcpy() 的区别：**

* strcpy()：遇到 \0 停止
* memcpy()：拷贝的内容和字节数有关，和拷贝内容无关

3）memmove()

memmove() 功能用法和 memcpy() 一样，区别在于：/dest 和 src 所指的内存空间重叠时，memmove() 仍然能够处理，不过执行效率比 memcpy() 低。

```c
int arr[]={1,2,3,4,5,6,7,8,9,10};

//dest 和 src 所指的内存空间重叠，使用 memmove() 更安全，不会报错
memmove(&arr[5],&arr[3],20);
```



4）memcmp()

```c
#include<string.h>
int memcmp(const void* s1,const void* s2,size_t n);
```

* 功能：比较 s1 和 s2 所指向内存区域的前 n 个字节(**逐字节比较**)
* 参数：
    * s1：内存地址1
    * s2：内存地址2
    * n：需要比较的前 n 个字节
* 返回值：
    * 相等：0
    * 大于：>0
    * 小于：<0

```c
int arr1[]={1,2,3,4,5,6,7,8,9,10};
int arr2[]={1,2,3,4,5};

memcmp(arr1,arr2,20);	// 0，相同

char str1[]="hello\0 world";
char str1[]="hello\0 world";
memcmp(str1,str2,13);	// 0，相同
```

**strcmp() 和 memcmp() 的区别：**

* strcmp()：遇到 \0 停止
* memcmp()：拷贝的内容和字节数有关，和拷贝内容无关

#### 3.5、内存常见问题

1）数组下标越界

```c
//数组下标越界
char ch[11]="hello world";

//堆空间越界
char* p=(char*)malloc(sizeof(char)*11);
strcpy(p,"hello world");
printf("%s\n",p);		//输出：hello world
free(p);				//err，开辟了11字节，使用和释放了12个
```

2）开辟内存大小和释放内存大小不一致

```c
int* p=(int*)malloc(0);
printf("%p\n",p);	//会输出一个地址
*p=100;
printf("%d\n",*p);	//输出：100
free(p);			//err，由于分配了 0 字节空间，p 相当于是野指针，但是释放了 4 字节，开辟内存大小和释放内存大小不一致
```

3）开辟空间和类型不对应

```c
int* p=(int*)malloc(10);		
p[0]=123;
p[1]=456;
//p[2]=789;
printf("%p\n",p);	//会输出一个地址
printf("%d\n",*p);	//输出：123
printf("%d\n",*(p+1));	//输出：456
//printf("%d\n",*(p+2));	//err，堆空间越界了

```

4）堆空间不允许多次释放

```c
int* p=(int*)malloc(sizeof(int)*10);		

free(p);	//释放 p，没问题
//free(p);	//此时 p 是野指针，再次释放会报错

//在释放完之后，应该让 p 指向空指针
p=NULL;

//空指针允许多次释放
free(p);
free(p);
free(p);
free(p);
free(p);
```

5）释放的指针应该和开辟空间时得到的指针相同

```c
int* p=(int*)malloc(sizeof(int)*10);	
for(int i=0;i<10;i++)
{
    *p=0;
    //指针叠加，不断改变指针方向，释放会出错
    p++;
}
free(p);	//err，指针叠加，不断改变指针方向，释放会出错
p=NULL;
```

4）值传递和地址传递

```c
void func(int* p)		//本质上还是值传递,传递的是指针变量
{
    p=(int*)malloc(sizeof(int)*10);	
}

voidfunc1(int** p)	//这个才是地址传递
{
    *p=(int*)malloc(sizeof(int)*10);	
}

int main()
{
    int *p=NULL;
    func(p);
    
    //func1(&p);
    
    for(int i=0;i<10;i++)
    {
        p[i]=i;			//err，这里 p 依然是空指针，操作空指针会报错
    }
    free(p);
}

//解决这里的问题可以使用地址传递，或者是使用函数的返回值
```

#### 3.6、二级指针对应的堆空间

```c
//开辟二级指针对应的堆空间，实际上就是一个 5*3 的二维整型数组，int arr[5][3]
int** p=(int**)malloc(sizeof(int*)*5);		//在堆空间中开辟
p[0]=(int*)malloc(sizeof(int)*3);			
p[1]=(int*)malloc(sizeof(int)*3);

//开辟一级指针对应的堆空间
for(int i=0;i<5;i++)
{
    p[i]=(int*)malloc(sizeof(int)*3);		//在堆空间中开辟，但是 p 和 p[i]之间不一定是连续的
}

//内存使用
for(int i=0;i<5;i++)
{
    for(int j=0;j<3;j++)
    {
        scanf("%d",&p[i][j]);
    }
}
for(int i=0;i<5;i++)
{
    for(int j=0;j<3;j++)
    {
        printf("%d ",p[i][j]);
    }
    printf("\n");
}

//空间释放，需要一级一级地释放，从内层向外层释放
for(int i=0;i<5;i++)
{
    free(p[i]);
}
f

```

## 八、复合类型（自定义类型）

### 1、结构体

#### 1.1、概述

* 将不同类型的数据组合成一个有机的整体。

#### 1.2、结构体变量的定义和初始化

1）结构体变量的定义

* 先声明结构体类型再定义变量名
* 在声明类型的同时定义变量
* 直接定义结构体类型变量（无类型名）

2）结构体类型和结构体变量的关系

* 结构体类型：相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元
* 结构体变量：系统根据结构体类型（内部成员状况）为之分配空间

3）结构体的定义格式：

```c
struct 结构体名
{
	成员列表
}
```

#### 1.3、结构体成员的使用

```c
//结构体定义
struct student
{
    char name[21];
    int age;
    int score;
    char addr[51];
}stu1,stu2,stu3;		//在定义结构体的时候可以直接进行变量创建和赋值

int main()
{
    //创建结构体变量
    //结构体类型 结构体变量名
     /*
    struct student stu;
    
   
    //stu.name="张三";	err，字符数组不能被赋值
    strcpy(sstu.name,"张三");
    stu.age=18;
    stu.score=100;
    //stu.addr="北京市朝阳区";
    strcpy(stu.addr,"北京市朝阳区");
    */
    
    //另一种快速赋值的方式
    struct student stu=("张三",18,100,"北京市朝阳区");
    
    printf("姓名：%s\n",stu.name);
    printf("年龄：%d\n",stu.age);
    printf("成绩：%d\n",stu.score);
    printf("地址：%s\n",stu.addr);
    
    
    return 0;
}
```

1）从键盘输入初始化结构体

```c
//结构体定义
struct student
{
    char name[21];
    int age;
    int score;
    char addr[51];
};

int main()
{
    struct student stu;
    scanf("%s%d%d%s",stu.name,&stu.age,&stu.score,stu.addr);
    printf("姓名：%s\n",stu.name);
    printf("年龄：%d\n",stu.age);
    printf("成绩：%d\n",stu.score);
    printf("地址：%s\n",stu.addr);
    
    return 0;
}
```

#### 1.4、结构体数组

```c
//结构体定义
struct student
{
    char name[21];
    int age;
    char sex;
    int score[3];
    char addr[51];
};

int main()
{
    struct student stu[3]=
    {
        {"张三",22,'M',88,99,10,"河北唐山"},
        {"李四",23,'F',59,59,59."河北邯郸"},		//也可以这样：{.addr="河北邯郸","李四",23,'F',59,59,59},
        {"王五",18,'M',100,100,100,"黑龙江大庆"}
    };
    //结构体数组元素个数计算
    printf("结构体数组大小：%d\n",sizeof(stu));						//288
    printf("结构体数组元素大小：%d\n",sizeof(stu[0]));				//96
    printf("结构体数组大小：%d\n",sizeof(stu)/sizeof(stu[0]));			//3
    
    for(int i=0;i<3;i++)
    {
        printf("姓名：%s\n",stu[i].name);
        printf("年龄：%d\n",stu[i].age);
        printf("性别：%s\n",stu[i].sex='M'?"男":"女");
        printf("成绩1：%d\n",stu[i].score[0]);
        printf("成绩2：%d\n",stu[i].score[1]);
        printf("成绩3：%d\n",stu[i].score[2]);
        printf("地址：%s\n",stu[i].addr);
    }
    return 0;
}
```

1）结构体元素个数计算

```c
//结构体数组元素个数计算
    printf("结构体数组大小：%d\n",sizeof(stu));						//288
    printf("结构体数组元素大小：%d\n",sizeof(stu[0]));				//96
    printf("结构体数组大小：%d\n",sizeof(stu)/sizeof(stu[0]));			//3
```

2）结构体成员需要偏移对齐

* 上面的结构体数组元素大小原本是：21+4+1+3*4+51=89字节，实际输出是 96字节。
* 结构体需要偏移对齐，以最大的数据类型为基准。

#### 1.5、结构体数组排序

```c
int main()
{
	struct student stu[3]=
    {
        {"张三",22,'M',88,99,10,"河北唐山"},
        {"李四",23,'F',59,59,59."河北邯郸"},		
        {"王五",18,'M',100,100,100,"黑龙江大庆"}
    };
    
    //按照年龄排序
    for(int i=0;i<3-1;i++)
    {
        for(int j=0;j<3-1-i;j++)
        {
            if(stu[j].age>stu[j+1].age)
            {
                struct student temp=stu[j];
                stu[j]=stu[j+1];
                stu[j+1]=temp;
            }
        }
    }
    for(int i=0;i<3;i++)
    {
        printf("姓名：%s\n",stu[i].name);
        printf("年龄：%d\n",stu[i].age);
        printf("性别：%s\n",stu[i].sex='M'?"男":"女");
        printf("成绩1：%d\n",stu[i].score[0]);
        printf("成绩2：%d\n",stu[i].score[1]);
        printf("成绩3：%d\n",stu[i].score[2]);
        printf("地址：%s\n",stu[i].addr);
    }
    return 0;
}

```

#### 1.6、开辟堆空间存储结构体

```c
typedef struct student ss;

struct student
{
    char name[21];
    int age;
    char sex;
    int score[3];
    char addr[51];
};

int main()
{
    //printf("%d\n",sizeof(struct student));		//96
    //开辟堆区存储结构体数组
    //struct student* p=(struct student*)macllo(sizeof(struct student));
    ss* p=(ss*)macllo(sizeof(ss)*3);
    printf("结构体指针的大小：%d\n",sizeof(p));		//32位系统输出4,64位系统输出8
    
    //赋值
    for(int i=0;i<3;i++)
    {
        scanf("%s%d%,c%d%d%d%s",p[i].name,&p[i].age,&p[i].sex,		//这里加逗号是为了防止输入时候用于分隔的空格被读入
              &p[1].score[0],&p[1].score[1],&p[1].score[2],p[i].addr);
    }
    
    for(int i=0;i<3;i++)
    {
        printf("姓名：%s\n",p[i].name);
        printf("年龄：%d\n",p[i].age);
        printf("性别：%s\n",p[i].sex='M'?"男":"女");
        printf("成绩1：%d\n",p[i].score[0]);
        printf("成绩2：%d\n",p[i].score[1]);
        printf("成绩3：%d\n",p[i].score[2]);
        printf("地址：%s\n",p[i].addr);
    }
    //释放空间
    free(p);
    return 0;
}
```

#### 1.7、结构体嵌套结构体

```c
/*
struct 技能
{
	名称
	等级
	伤害
	范围
	耗蓝
	冷却
};

struct 人物信息
{
	等级
	经验
	金钱
	hp
	mp
	力量
	智力
	敏捷
	struct 技能 skills[4]
};

struct 人物信息 info;
info.skills[0].名称;
*/

struct scores
{
    int c;
    int cpp;
    int cs;
};

struct student
{
    char name[21];
    int age;
    struct scores ss;
    char addr[51];
};

int main()
{
    struct student stu={"貂蝉",18,99,99,99,"徐州"};
    printf("%s\n%d\n%d\n%d\n%d\n%s\n",stu.name,stu.age,stu.ss.c,stu.ss.cpp,stu.ss.cs,stu.a);
    
    printf("成绩结构体大小：%d\n",sizeof(struct scores));		//92
    printf("学生结构体大小：%d\n",sizeof(struct student));		//92
    return 0;
}
```

#### 1.8、结构体赋值

* 结构体赋值，会产生一个独立的变量（结构体成员为非指针的情况下）

```c
struct student
{
    char name[21];
    int age;
    int score;
    char addr[51];
};

int main()
{
    struct student stu={"孙尚香",26,60,"巴蜀"};
    struct student s1=stu;		//结构体赋值，会产生一个独立的变量
    strcpt(s1.name,"甘夫人");
    
    printf("%s\n",stu.name);	//孙尚香	这里s1和stu是两个独立的内存空间
}
```

#### 1.9、结构体和指针

1）指向普通结构体变量的指针

* 开辟堆空间存储结构体

2）结构体成员为指针类型

```c
struct student
{
    char* name;
    int age;
    int* scores;
    char* addr;
};

int main()
{
    struct student stu;
    //stu.name="张三";	如此赋值没错，但是name指向一个字符串常量，不可修改
    stu.name=(char*)malloc(sizeof(char)*21);
    strcpy(stu.name,"张三")；
    stu.scores=(int*)malloc(sizeof(int)*3);
    stu.addr=(char*)malloc(sizeof(char)*51);
    str.age=18;
    stu.scores[0]=88;
    stu.scores[1]=77;
    stu.scores[2]=99;
    strcpy(stu.addr,"北京市昌平区");
    
    free(stu.name);
    free(stu.scores);
    free(stu.addr);
    return 0;
}
```

3）结构体指针：指向结构体的指针

* 通过指针访问结构体成员，利用指针的取值运算

```c
//通过指针访问结构体成员，利用指针的取值运算
//结构体变量.成员
printf("%s\n",(*p).name);
printf("%d\n",(*p).age);
```

* 过指针访问结构体成员，利用指针的指向运算符

```c
//通过指针访问结构体成员，利用指针的指向运算符
//结构体指针->成员
printf("%s\n",p->name);
printf("%d\n",p->age);
    
```



```c
struct student
{
    char name[21];
    int age;
    int scores;
    char addr[51];
};

int main()
{
    struct student stu={"林冲",30,100,100,100,"汴京"};
    struct student* p;
    p=&stu;
    
    //通过指针访问结构体成员，利用指针的取值运算
    printf("%s\n",(*p).name);
    printf("%d\n",(*p).age);
    
    //通过指针访问结构体成员，利用指针的指向运算符
    printf("%s\n",p->name);
    printf("%d\n",p->age);
    
    return 0;
}
```

```c
typedef struct student ss;
struct student
{
	char* name;
    int age;
    int* scores;
    char* addr;
};

int main()
{
    ss* p=(ss*)malloc(sizeof(ss)*3);
    
    //开辟堆空间
    for(int i=0;i<3;i++)
    {
        (p+i)->name=(char*)malloc(sizeof(char)*21);
        p[i].scores=(int*)malloc(sizeof(int)*3);
        p[i].addr=(char*)malloc(sizeof(char)*51);
    }
    
    //输入
    for(int i=0;i<3;i++)
    {
        scanf("%s%d%d%d%d%s",(p+i)->name,&p[i].age,&p[i].scores[0],
              p[i].scores[1],&p[i].scores[2],p[i].addr);
    }
    
    //输出
    for(int i=0;i<3;i++)
    {
        printf();
    }
    
    //释放堆空间
    for(int i=0;i<3;i++)
    {
        free(p[i].name);
        free((p+i)->scores);
        free(p[i].addr);
    }
    free(p);
}
```

#### 1.10、结构体做函数参数

1）结构体普通变量做函数参数：值传递

```c
/*
typedef struct student ss;
struct student
{
    char name[21];
    int age;
    int score;
    char addr[51];
};

void func(ss stu)	//值传递
{
    strcpy(stu.name,"卢俊义");
    printf("%s\n",ss.name);		//卢俊义
}
int main()
{
    ss stu={"宋江",50,101,"水泊梁山"};
    func(stu);		//值传递
    printf("%s\n",stu.name);	//宋江
    
    return 0;
}
*/
typedef struct student ss;
struct student
{
    char* name;
    int age;
    int score;
    char addr[51];
};

void func(ss stu)	//值传递
{
    strcpy(stu.name,"卢俊义");
    printf("%s\n",ss.name);		//卢俊义
}

void func1(ss stu)	//值传递
{
    stu.name=(char*)malloc(sizeof(char)*21);
    strcpy(stu.name,"卢俊义");
    printf("%s\n",ss.name);		//卢俊义
}
int main()
{
    ss stu={NULL,50,101,"水泊梁山"};
    stu.name=(char*)malloc(sizeof(char)*21);
    strcpy(stu.name,"宋江");
    func1(stu);		//值传递
    printf("%s\n",stu.name);	//宋江
    
    func(stu);		//值传递
    printf("%s\n",stu.name);	//卢俊义
    
    return 0;
}

```

2）结构体指针变量做函数参数：地址传递

```c
typedef struct student ss;
struct student
{
    char name[21];
    int age;
    int score;
    char addr[51];
};

void func(ss* p)	//地址传递
{
    strcpy(p->name,"公孙胜");
    printf("%s\n",p->name);		//公孙胜
}
int main()
{
    ss stu={"吴用",50,101,"水泊梁山"};
    func(&stu);		//地址传递
    printf("%s\n",stu.name);	//公孙胜
    
    return 0;
}
```

3）结构体数组做函数参数：退化为指针，地址传递

```c
typedef struct student ss;
struct student
{
    char name[21];
    int age;
    int score;
    char addr[51];
};

//数组作为函数参数，退化为指针，需要传递元素个数
void BubbleSort(ss* stu,int length)	//地址传递
{
    printf("%d\n",sizeof(stu));
    for(int i=0;i<3-1;i++)
    {
        for(int j=0;j<3-i-1;j++)
        {
            if(stu[j].age>stu[j+1].age)
            {
                ss temp=stu[j];
                stu[j]=stu[j+1];
                stu[j+1]=temp;
            }
        }
    }
}

int main()
{
    ss stu[3]=
    {
        {"鲁智深",30,33,"五台山"},
        {"呼延灼",45,44,"汴京"},
        {"顾大嫂",28,55,"汴京"}
    };
    BubbleSort(stu,3);		//输出：4	即指针的大小
    
    
    return 0;
}
```

4）const 修饰结构体指针形参变量

* 与 const 修饰其他变量形参是一致的
* const 修饰结构体指针类型

```c
typedef struct student ss;
struct student
{
    char name[21];
    int age;
    int scores[3];
    char addr[51];
};

int main()
{
    ss stu1={"孙悟空",700,101,101,101,"花果山"};
    ss stu2={"猪八戒",1200,1001,1001,1001,"高老庄"};
    const ss* p=&stu1;		//const 修饰结构体指针类型
    p=&stu2;	//OK
    p->age=888;		//err
    (*p).age=888;	//err
    return 0;
}
```

* const 修饰结构体指针变量

```c
typedef struct student ss;
struct student
{
    char name[21];
    int age;
    int scores[3];
    char addr[51];
};

int main()
{
    ss stu1={"孙悟空",700,101,101,101,"花果山"};
    ss stu2={"猪八戒",1200,1001,1001,1001,"高老庄"};
    ss* const p=&stu1;		//const 修饰结构体指针变量
    p=&stu2;	//err
    p->age=888;		//OK
    (*p).age=888;	//OK
    strcpy(p->name,"沙悟净");		//OK
    return 0;
}
```

* const 修饰结构体指针变量和指针类型

```c
typedef struct student ss;
struct student
{
    char name[21];
    int age;
    int scores[3];
    char addr[51];
};

int main()
{
    ss stu1={"孙悟空",700,101,101,101,"花果山"};
    ss stu2={"猪八戒",1200,1001,1001,1001,"高老庄"};
    const ss* const p=&stu1;		//const 修饰结构体指针变量和指针类型
    p=&stu2;	//err
    p->age=888;		//err
    (*p).age=888;	//err
    strcpy(p->name,"沙悟净");		//err
    
    ss** pp=&p;
    (*pp)->age=1234;	//OK
    *pp=&stu2;			//OK
    
    **PP.age=789;		//OK
    
    return 0;
}
```

### 2、共用体（联合体）

* 联合体 union 还一个能在同一个存储空间存储不同类型数据的类型；
* 联合体所占的内存长度等于其最长成员的长度倍数；
* 同一内存段可以用来存放几种不同类型的成员，但是每一瞬时只有一种起作用；
* 共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员的值会被覆盖；
* 共用体变量的地址和它的各成员的地址都是同一地址。

```c
union Var
{
    int a;
    float b;
    double c;
    char d;
    short f;
    //short f[6];	//如果这样，那么sizeof(Var)=16
    //内存对齐，最大类型的整数倍对齐
};

int main()
{
    union Var uVar;
    /*
    uVar.a=100;
    printf("%d\n",uVar.a);		//100
    */
    
    uVar.a=100;
    uVar.b=3.14;
    printf("%d\n",uVar.a);		//乱码
    printf("%f\n",uVar.b);		//3.14
    
    printf("%d\n",sizeof(uVar));		//8	大小和最大的类型有关
    
    printf("%p\n",&uVar);
    printf("%p\n",&uVar.a);
    printf("%p\n",&uVar.b);
    printf("%p\n",&uVar.c);
    printf("%p\n",&uVar.d);
    printf("%p\n",&uVar.e);
    printf("%p\n",&uVar.f);		//输出的地址相同
    
    return 0;
}
```

### 3、枚举

* 枚举：将变量值一一列举出来，变量的值只限于列举出来的值的范围内。

#### 3.1、枚举的定义：

```c
enum 枚举名
{
    枚举值表
}
```

* 在枚举值表中应列出所有可用值，也称为枚举元素
* 枚举值是常量，不能在程序中用赋值语句再对它赋值
* 枚举元素本身由系统定义了一个表示序号的数值从 0 开始顺序定义为：0、1、2、……

```c
enum color
{
    red,blue,green,pink,yellow,black,white
};

//也可以你使用系统默认的值，自定义赋值
enum color1
{
    red=10,blue,green,pink,yellow=20,black,white
};

int main()
{
    int value;
    scanf("%d",&value);
    enum color colorName;
    switch(value)
    {
    case red:
        printf("红色\n");
    	break;
    case blue:
        printf("蓝色\n");
    	break;
    case green:
        printf("绿色\n");
    	break;
    case pink:
        printf("粉色\n");
    	break;
    case yellow:
        printf("黄色\n");
    	break;
    case black:
        printf("黑色\n");
    	break;
    case white:
        printf("白色\n");
    	break;
    default:
        break;
    }
    return 0;
}
```

#### 3.2、枚举流程控制案例

```c
enum TYPE
{
    run,attack,skill,dance=10,showUI,frozen=20,dizzyn,dath,moti=30
    //值分别为：0、1、2、10、11、20、21、22、30
}type;

int main()
{
    int value;
    while(1)
    {
        scanf("%d",&value);
        switch(type)
    	{
        	case run:
                printf("正在移动中……\n");
                //value=30;
           	 	break;
        	case attack:
                printf("正在攻击中……\n");
            	break;
        	case skill:
                printf("正在施法中……\n");
            	break;
        	case dance:
                printf("正在跳舞中……\n");
            	break;
        	case showUI:
                printf("正在显示徽章中……\n");
            	break;
        	case frozen:
                printf("正在被冰冻中……\n");
            	break;
        	case dizzyn:
                printf("正在被眩晕中……\n");
            	break;
        	case dath:
                printf("死亡……\n");
                return 0;
            	break;
        	case moti:
                printf("等待释放命令中……\n");
            	break;
        	default:
            	break;
    	}
    }
    
    return 0;
}
```

### 4、typedefine

* 为一种数据类型（基本类型或自定义类型）定义一个新名字，不能创建新类型
* 与 #define 不同，typedef 仅限于数据类型，不能是表达式或者具体的值
* #define 发生在预处理，typedef 发生在编译阶段

1）为已经存在的数据类型取别名

```c
typedef unsigned int ui;
typedef struct student
{
    char name[21];
    int age;
    int score;
    char addr[51];
}ss;

int main()
{
    ui a=10;
    ss stu;
    return 0;
}
```

2）定义函数指针

## 九、文件操作

### 1、概述

#### 1.1、磁盘文件和设备文件

1）磁盘文件：

指一组相关数据的有序集合，通常存储在外部介质（如磁盘）上，使用时才调入内存

2）设备文件：

在操作系统中，把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于文件的读写

#### 1.2、磁盘文件的分类

* 物理上所有的磁盘文件本质上都是一样的：以字节为单位进行顺序存储
* 从用户或者操作系统使用的角度（逻辑上）把文件分为：
    * 文本文件：基于字符编码的文件
    * 二进制文件：基于值编码的文件

#### 1.3、文本文件和二进制文件

1）文本文件

* 基于字符编码，常见编码有 ASCII、UNICODE等
* 一般可以使用文本编辑器直接打开
* 数 5678 以 ASCII 存储形式为：00110101 00110110 00110111 00111000

2）二进制文件

* 基于值编码，自己根据具体应用，指定某个值是什么意思
* 把内存中的数据按其在内存中的存储形式鸳鸯输出到磁盘上
* 数 5678 的存储形式（二进制码）为：00010110 00101110

### 2、文件的打开和关闭

#### 2.1、文件指针

* 在 C 语言中，用一个指针变量指向一个文件，这个指针称为文件指针
* FILE 是系统使用 typedef 定义出来的有关文件信息的一种结构体类型，结构体中含有文件名、文件状态和文件当前位置等信息
* 声明 FILE 结构体的信息包含在 stdio.h 头文件中
* C 语言中有三个特殊的文件指针由系统默认打开，用户无需定义即可直接使用：
    * stdin：标准输入，默认为当前终端（键盘），使用 scanf、getchar 函数默认从此终端获得数据
    * stdout：标准输出，默认为当前终端（屏幕），使用 printf、puts 函数默认输出信息到此终端
    * stderr：标准出错，默认为当前终端（屏幕），使用 perror 函数默认输出信息到此终端

```c
//FILE 结构体内容
typedef struct
{
    short level;			//缓冲区满或者空的程度
    unsigned flags;			//文件状态标志
    char fd;				//文件描述符
    unsigned char hold;		//如无缓冲区，不读取字符
    short bsize;			//缓冲区的大小
    unsigned char *buffer;	//数据缓冲区的位置
    unsigned ar;			//指针当前的指向
    unsigned istemp;		//临时文件指示器
    short token;			//用于有效的检查
}FILE;
```

#### 2.2、文件打开

任何文件在使用之前都应该先打开：

```c
#include<stdio.h>
FILE* fopen(const char* filename,const char* mode);
```

* 功能：打开文件
* 参数：
    * filename：需要打开的文件名，根据需要加上路径
    * mode：打开文件的模式设置
* 返回值：
    * 成功：文件指针
    * 失败：NULL

3）文件打开模式的几种形式：

|  打开模式   |                             含义                             |
| :---------: | :----------------------------------------------------------: |
|  r 或者 rb  | 以只读方式打开一个文本文件（不创建文件，若文件不存在则报错） |
|  w 或者 wb  | 以写方式打开文件（如果文件存在则清空文件，如果文件不存在则创建一个文件） |
|  a 或者 ab  |  以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件  |
| r+ 或者 rb+ |          以可读、可写的方式打开文件（不创建新文件）          |
| w+ 或者 wb+ | 以可读、可写的方式打开文件（如果文件存在则清空文件，如果文件不存在则创建一个文件） |
| a+ 或者 ab+ | 以添加方式打开文件，并在文件末尾更改文件，若文件不存在则创建文件 |

**注意：** 

* b 是二进制的意思，b 只在 windows 下有效，在 Linux 用 r 和 rb 的结果是一样的
* Unix 和 Linux 下所有的文本文件行都是以 \n 结尾，而 Windows 所有的文本文件都是以 \r\n 结尾
* 在 Windows 平台下，以”文本“方式打开文件，不加 b：
    * 当读取文件的时候，系统会将所有的 \r\n 转换成 \n
    * 当文件写入的时候，系统会将 \n 转换成 \r\n 写入
    * 以二进制方式打开文件，则读写过程都不会进行 \n 和 \r\n 的转换
* 在 Unix 和 Linux 平台下，“文本”与“二进制”模式没有区别，\r\n 作为两个字符原样输入输出

```c
int main()
{
    FILE* fp=fopen("D:/a.txt","r");
    if(fp==NULL)
    {
        printf("打开文件失败\n");
        //原因：
        //1、找不到文件
        //2、文件的权限不满足（文件权限：r, w, x）
        //3、程序打开状态的文件数超出上限（65535）
        return -1;
    }
    printf("打开文件成功：%p\n",fp);	//输出的是一个地址
    
    fclose(fp);		//在使用文件指针的过程中，关闭当前文件之前，不要去改变文件指针的指向，因为改变之后，打开的文件就无法关闭了
    return 0;
}
```

#### 2.3、文件关闭

任何文件在使用后应该关闭：

* 打开的文件会占用内存资源，如果总是打开不关闭，会消耗很多内存
* 一个进程同时打开的文件数是有限的，超过最大同时打开文件数，再次调用 fopen 打开文件会失败
* 如果没有明确调用 fclose 关闭打开的文件，那么程序在退出的时候，操作系统会同一关闭

```c
#include<stdio.h>
int fclose(FILE* stream);
```

* 功能：关闭先前 fopen 打开的文件，此动作让缓冲区的数据写入文件中，并释放系统提供的文件资源
* 参数：stream，文件指针
* 返回值：
    * 成功：0
    * 失败：-1

### 3、文件的顺序读写

#### 3.1、按照字符读写文件 fgetc、fputc

1）写文件

```c
#include<stdio.h>
int fputc(int ch,FILE* stream);

```

* 功能：将 ch 转换为 unsigned char 后写入 stream 指定的文件中
* 参数：
    * ch：需要写入文件的字符
    * stream：文件指针
* 返回值：
    * 成功：成功写入文件的字符
    * 失败：返回-1

**在写入的过程中，光标在写入一个字符完成后，光标会自动向后移动一位**

```c
int main()
{
    //以写的方式打开文件，如果文件存在则清空文件，如果文件不存在则创建一个文件
    FILE* fp=fopen("D:/a.txt","w");
    if(!fp)
    {
        printf("文件打开失败\n");
        return -1;
    }
    char ch='a';
    //字符写入
    fputc(ch,fp);
    
    
	fclose(fp);    
    return 0;
}
```

```c
int main()
{
    //以写的方式打开文件，如果文件存在则清空文件，如果文件不存在则创建一个文件
    FILE* fp=fopen("D:/a.txt","w");
    if(!fp)
    {
        printf("文件打开失败\n");
        return -1;
    }
    
    char ch;
    while(1)
    {
        scanf("%c",&ch);
        if(ch=='@')
            break;
        fputc(ch,fp);
    }
    
    fclose(fp);
    return 0;
}
```



2）读文件

```c
#include<stdio.h>
int fgetc(FILE* stream);
```

* 功能：从 stream 指定的文件中读取一个字符
* 参数：
    * stream：文件指针
* 返回值：
    * 成功：返回读取到的字符
    * 失败：返回-1

* * 

```c
//文件字符读写
int main()
{
     FILE* fp=fopen("D:/a.txt","r");
    if(!fp)
    {
        printf("文件打开失败\n");
        return -1;
    }
    
    char ch;
    //文件的字符读取
    ch=fgetc(fp);
    printf("%c\n",ch);
    //读取下一个，不需要改变文件指针，每次读取完一个字符之后，光标会自动移动到下一个字符处
    //这里不要手动改变文件指针的值，否则后面文件关闭难以实现
    //文件默认结尾为 -1，即文件以 -1 作为结尾标志
    ch=fgetc(fp);
    printf("%c\n",ch);
    
    //关闭文件
    fclose(fp);
    
    return 0;
}
```

```c
//文件字符读写
int main()
{
     FILE* fp=fopen("D:/a.txt","r");
    if(!fp)
    {
        printf("文件打开失败\n");
        return -1;
    }
    
    char ch;
    while((ch=fgetc(fp))!=EOF)
    {
        printf("%c",ch);
    }
    
    //关闭文件
    fclose(fp);
    
    return 0;
}
```



3）文件结尾

* 在 C 语言中，EOF 表示文件结束符，在 while 循环中以 EOF 作为文件结束标志，EOF 是一个宏，其值为 -1
* 这种以 EOF 作为文件结束标志的文件，必须是文本文件
* 当把数据以二进制形式存放到文件中时，就会有 -1 出现，此时不能使用 EOF 作为二进制文件的结束标志。可以使用 feof  函数来判断文件是否结束
* feof 函数既可以判断二进制文件，又可以判断文本文件

```c
#define EOF (-1)
```

```c
#include<stdio.h>
int feof(FILE* stream);

```

* 功能：检测是否读取到了文件结尾。判断的是最后一次 **读取操作的内容**，不是当前位置内容（上一个读取内容）
* 参数：stream，文件指针
* 返回值：
    * 非 0 值，已经到文件结尾
    * 0，没有到文件结尾

#### 3.2、文件加密解密

```c
//加密
int main()
{
    FILE* fp1=fopen("D:/解密.txt","r");
    FILE* fp2=fopen("D:/加密.txt","w");
    if(!fp1||!fp2)
    {
        return -1;
    }
    
    char ch;
    while((ch=fgetc(fp1))!=EOF)
    {
        ch++;
        fputc(ch,fp2);
    }
    fclose(fp1);
    fclose(fp2);
    
    return 0;
}


```

```c
//解密
int main()
{
    FILE* fp1=fopen("D:/加密.txt","r");
    FILE* fp2=fopen("D:/解密文件.txt","w");
    if(!fp1||!fp2)
    {
        return -1;
    }
    
    char ch;
    while((ch=fgetc(fp1))!=EOF)
    {
        ch--;
        fputc(ch,fp2);
    }
    fclose(fp1);
    fclose(fp2);
    
    return 0;
}
```

#### 3.3、文件行读写 fgets、fputs

1）写文件：fputs

```c
#include<stdio.h>
int fputs(const char *str,FILE *stream);
```

* 功能：将 str 所指定的字符串写入到 stream 指定的文件中，字符串结束符 '\0' 不写入文件
* 参数：
    * str，字符串
    * stream，文件指针，如果把字符串输出到屏幕，固定写为 stdout
* 返回值：
    * 成功，0；
    * 失败，-1

```c
//从字符串写入
int main()
{
    FILE* fp=fopen("D:/a.txt","r");
    if(!fp)
    {
        return -1;
    }
    
    /*
    char ch[]="你瞅啥瞅你咋地";	
    fputs(ch,fp);	//文件中写入：你瞅啥瞅你咋地
    */
    
    /*
    char ch[]="你瞅啥\n瞅你咋地";	
    fputs(ch,fp);	//文件中写入两行内容，第一行：你瞅啥		第二行：瞅你咋地	
    */
    
    char ch[]="你瞅啥\0瞅你咋地";	
    fputs(ch,fp);	//文件中写入：你瞅啥
    //及与字符串的行写入，因此在字符串中遇到字符串结束符，写入也就在这里停止了
    
    fclose(fp);
    
    return 0;
}
```

```c
//从键盘写入
int main()
{
    FILE* fp=fopen("D:/a.txt","r");
    if(!fp)
    {
        return -1;
    }
    char* p=(char*)malloc(sizeof(char)*1024);
    while(1)
    {
        memset(p,1024,0);

        scanf("%[^\n]",p);		//接收非换行的字符
        getchar();				//把缓冲区的换行符吃掉

        
        //也可以使用 fgets函数进行输入
        
        //停止输入的命令
        if(!strcmp(p,"comm=exit")
           break;
           
        strcat(p,'\n');
        fputs(p,fp);
    }
    
    free(p);
    fclose(fp);
    
    return 0;
}
```



2）读文件：fgets

```c
# include<stdio.h>
char *fgets(char *s, int size,FILE *stream);
```

* 功能：从 stream 指定的文件内读入字符，保存到所指定的内存空间，直到出现换行字符、读到文件末尾或是读了 size-1 个字符为止，最后会自动加上 '\0' 字符作为结束标志。
* 参数：
    * s，字符串；
    * size，指定最大读取字符串的长度（size-1）
    * stream：文件指针，如果读取键盘输入的字符串，固定写作 stdin
* 返回值：
    * 成功：成功读取的字符串
    * 读到文件尾或者出错：NULL

```c
int main()
{
    FILE* fp=fopen("D:/a.txt","r");
    if(!fp)
    {
        return -1;
    }
    
    char* p=(char*)malloc(sizeof(char)*100);
    memset(p,0,100);
    fgets(p,100,fp);	//如果一次读取的大小小于一行，下次就会接着这里继续读
    
    printf("%s\n",p);
    
    free(p);
    fclose(fp);
    
    return 0;
}
```

```c
int main()
{
    FILE* fp=fopen("D:/a.txt","r");
    if(!fp)
    {
        return -1;
    }
    
    char* p=(char*)malloc(sizeof(char)*100);
    while(!feof(fp))
    {
        memset(p,100,0);
        fgets(p,100,fp);
        
        printf("%s",p);
    }
    
    free(p);
    fclose(fp);
    
    return 0;
}
```

#### 3.4、四则运算

```c
//在文件中生成 100 到 10以内的四则运算题目
enum opt
{
    add,sub,mul,dive
};
int main()
{
    srand((size_t)time(NULL));
	FILE* fp=fopen("D:/四则运算.txt","w");
    if(!fp)
        return -1;
    int a,b;
    char c;
    char* p=(char*)malloc(sizeof(char)*20);
    for(int i=0;i<100;i++)
    {
        a=rand()%10+1;
        b=rand()%10+1;
        switch(rand()%4)
        {
            case add:
                c='+';
                break;
            case sub:
                c='-';
                break;
            case mul:
                c='*';
                break;
            case dive:
                c='/';
                break;
        }
        memset(p,20,0);
        sprintf(p,"%d %c %d = ",a,c,b);
        fputs(p,fp);
    }
    
    free(p);
    p=NULL;
    fclose(fp);
    fp=NULL;
    
    return 0;
}
```

```c
//读取上面生成的四则运算题目的文件，对其进行计算，并存放到另一个文件中
enum opt
{
    add,sub,mul,dive
};
int main()
{
	FILE* fp1=fopen("D:/四则运算.txt","r");
    FILE* fp2=fopen("D:/四则运算结果.txt","w");
    if(!fp1||fp2)
        return -1;
    
    // !feof(fp)		EOF -1
    for(int i=0;i<100;i++)
    {
        char* p=(char*)malloc(sizeof(char)*20);
        memset(p,20,0);
        fgets(p,20,fp);
        int a,b;
    	char c;
        
        sscanf(p,"%d %c %d = ",&a,&cc,&b);
        int sum=0;
        switch(c)
        {
            case '+':sum=a+b;break;
            case '-':sum=a-b;break;
            case '*':sum=a*b;break;
            case '/':sum=a/b;break;
        }
        memset(p,0,20);
        sprintf(p,"%d %c %d = %d\n",a,c,b,sum);
        fputs(p,fp);
    }
    
    free(p);
    p=NULL;
    fclose(fp);
    fp=NULL;
    
    return 0;
}
```

#### 3.4、按照格式化文件 fprintf、fscanf

1）写文件

```c
#include<stdio.h>
int fprintf(FILE* stream,const char* format,…);
```

* 功能：根据参数 format 字符串来转换并格式化数据，然后将结果输出到 stream 指定的文件中，指定出现字符串结束符 \0 为止
* 参数：
    * stream：已经打开的文件
    * format：字符串格式，用法和 printf 一致
* 返回值：
    * 成功：实际写入文件的字符个数
    * 失败：-1

```c
//字符串读取
int main()
{
    FILE* fp=fopen("D:/a.txt","r");
    if(!fp)
        return -1;
    
    char* p=(char*)malloc(sizeof(char)*1024);
    fprintf(fp,"%s",p);
    
    int a=10;
    int b=2;
    int c=12;
    fprintf(fp,"%05d + %05d = %05d\n",a,b,c);		//在文件中写入了：00010 + 00002 = 00012
    
    free(p);
    fclose(fp);
    return 0;
}
```



2）读文件

```c
#include<stdio.h>
int fscanf(FILE* stream,const char* format,…);
```

* 功能：从 stream 指定的文件读取字符串，并根据参数 format 字符串转换并格式化数据
* 参数：
    * stream：已经打开的文件
    * format：字符串格式，用法和 scanf 一致
* 返回值：
    * 成功：成功转换的值的个数
    * 失败：-1

```c
//字符串读取
int main()
{
    FILE* fp=fopen("D:/a.txt","r");
    if(!fp)
        return -1;
    
    char* p=(char*)malloc(sizeof(char)*1024);
    fscanf(fp,"%s",p);
    printf("%s\n",p);		//格式化读取过程中，通过 %3s，%5c 等方式，可以限定读取的宽度
    //如果使用 %5c 的方式限定读取宽度，需要先初始化字符数组为 0，这样可以在读取结束之后，在末尾自动有字符串结束符，可以直接以字符串形式输出
    
    fscanf(fp,"%s",p);
    printf("%s\n",p);		//fscanf 在读取过程中，遇到空格和回车就结束读取，因此无法读取到空格和换行
    
    free(p);
    fclose(fp);
    return 0;
}
```

```c
//数据读取
int main()
{
    FILE* fp=fopen("D:/a.txt","r");
    if(!fp)
        return -1;
    
    int a,b,c;
    
    /*
    fscanf(fp,"%d",&a);		//格式化读取文件中的数据
    printf("%d\n",a);
    */
    //文件中在第一行写的是 3*6=18
    fscanf(fp,"%d*%d=%d",&a,&b,&c);		//格式化读取文件中的数据
    printf("%d\n%d\n%d\n",a,b,c);		//输出：3,6,18
    //读取过程中，如果是以十进制方式读取，那么遇到非十进制数就停止，
    //同样地，对于八进制和十六进制也是读到非八进制数字和非十六进制数字就停止了
    
    free(p);
    fclose(fp);
    return 0;
}
```

```c
//四则运算
int main()
{
	FILE* fp=fopen("D:/四则运算.txt","w");
    if(!fp)
        return -1;
    
    srand((size_t)time(NULL));
    
    int a,b;
    char c;
    for(int i=0;i<100;i++)
    {
        a=rand()%10+1;
        b=rand()%10+1;
        switch(rand()%4)
        {
            case 0:c='+';break;
            case 1:c='-';break;
            case 2:c='*';break;
            case 3:c='/';break;
        }
        fprintf(fp,"%d %c %d =\n",a,c,b);
    }
    
    fclose(fp);
	return 0;
}
```

#### 3.5、大文件数据排序

```c
//大文件数据排序，生成数据
int main()
{
	FILE* fp=fopen("D:/数据.txt","w");
    if(!fp)
        return -1;
    srand((size_t)time(NULL));
    
    //填入随机数
    for(i=0;i<10000;i++)
    {
        fprintf(fp,"%d\n",rand()%1024);
    }
    
    
    fclose(fp);
	return 0;
}
```

```c
//大文件数据排序，数据排序
//冒泡排序
void Bubble(int* src,int len)
{}

//哈希排序
void hashSort(const int* arr,int* sortedArr,int len)
{
    for(int i=0;i<1000;i++)
    {
        sortedArr[arr[i]]++;
    }
}

int main()
{
	FILE* fp1=fopen("D:/数据.txt","r");
    FILE* fp2=fopen("D:/数据排序.txt","w");
    if(!fp1||!fp2)
        return -1;
    
    //冒泡排序
   	int* arr=(int*)malloc(sizeof(int)*10000);
    for(int i=0;i<10000;i++)
    {
        fscanf(fp1,"%d\n",&arr[i]);
    }
    /*
    Bubble(arr,10000);
    for(int i=0;i<10000;i++)
    {
        fprintf(fp2,"%d\n",arr[i]);
    }
    */
    int sortedArr[1024]={0};
    hashSort(ar,sortedArr,10000);
    for(int i=0;i<1024;i++)
    {
        for(int j=0;j<sortedArr[i];j++)
        {
            fprintf(fp2,"%d\n",i);
        }
    }
    
    fclose(fp1);
    fclose(fp2);
    free(arr);
	return 0;
}
```

#### 3.6、按照块读写文件 fread、fwrite（针对二进制文件的操作）

1）写文件

```c
#include<stdio.h>
size_t fwrite(const void* ptr,size_t size,size_t nmemb,FILE* stream);
```

* 功能：以数据块的方式给文件写入内容
* 参数：
    * ptr：准备写进文件的数据地址
    * size：指定写入文件内容的块数据的大小
    * nmemb：写入文件的块数        写入文件的数据总大小：size*nmemb
    * stream：已经打开的文件指针
* 返回值：
    * 成功：实际成功写入文件数据的块数，此值和 nmemb 相等
    * 失败：0

```c
int main()
{
	FILE* fp=fopen("D:/a.txt","wb");
    if(!fp)
        return -1;
    int a=5678;
    fwrite(&a,sizeof(int),1,fp);	//以二进制形式在文件中存入了 5678，占 4 个字节
    fclose(fp);
    fp=NULL;
    
    FILE* fp1=fopen("D:/a.txt","rb");
    int value;
    fread(&value,sizeof(int),1,fp);
    printf("%d\n",value);		//5678
    fclose(fp1);
    fp1=NULL;
    
	return 0;
}
```

```c
int main()
{
	FILE* fp=fopen("D:/a.txt","wb");
    if(!fp)
        return -1;
    int arr[]={1,2,3,4,5,6,7,8,9,10};
    fwrite(arr,sizeof(int),10,fp);	
    fclose(fp);
    fp=NULL;
    
    FILE* fp1=fopen("D:/a.txt","rb");
    int value[]={0};
    fread(value,sizeof(int),10,fp);		//写成：fread(value,10,4,fp);	也可以，其他写法也都可以，保证大小总一致就可以
    for(int i=0;i<10;i++)
    {
        printf("%d\n",value[i]);	//1 2 3 4 5 6 7 8 9 10
    }
    fclose(fp1);
    fp1=NULL;
    
	return 0;
}
```

```c
//文件读写结构体
typedef struct student
{
    char name[21];
    int age;
    int score;
    char addr[51];
}stu;

int main()
{
    stu ss[3]=
    {
        {"单据",9,10,"附件为废物"},
        {"层面上年纪",2,110,"附吃什么词废物"},
        {"层面上墨",90,120,"VN无法未付款"}
    };
    FILE* fp=fopen("D:/a.txt","wb");
    if(!fp)
        return -1;
    for(int i=0;i<3;i++)
    {
        fwrite(&ss[i],sizeof(stu),1,fp);
    }
    fclose(fp);
    
    stu* ss=(stu*)malloc(sizeof(stu)*3);
    FILE* fp1=fopen("D:/a.txt","rb");
    if(!fp1)
        return -1;
    
    while(!feof(fp1))
    {
        int i=0;
        fread(ss+i,sizeof(stu),1,fp1);
        i++;
        
    }
    for(int i=0;i<3;i++)
    {
        printf("姓名：%s\n"，ss[i].name);
        printf("年龄：%d\n"，ss[i].age);
        printf("成绩：%d\n"，ss[i].score);
        printf("地址：%s\n"，ss[i].addr);
        
    }
    
    free(ss);
    fclose(fp1);
    return 0;
}
```

2）读文件

```c
#include<stdio.h>
size_t fread(const void* ptr,size_t size,size_t nmemb,FILE* stream);
```

* 功能：以数据块的方式从文件中读取内容
* 参数：
    * ptr：准备读入文件数据的变量地址
    * size：指定读取文件内容的块数据的大小
    * nmemb：读取文件的块数        读取文件的数据总大小：size*nmemb
    * stream：已经打开的文件指针
* 返回值：
    * 成功：实际成功读取文件数据的块数，此值和 nmemb 相等
    * 失败：0

#### 3.7、大文件拷贝

```c
#define SIZE 1024
int main(int argc,char* argv[])
{
    for(int i=0;i<argc;i++)
    {
        printf("%s\n",arfv[i]);
    }
    
    //用户输入参数缺少
    if(argc<3)
    {
        printf("缺少参数\n");
        return -1;
    }
    
    //argv[0] 程序名称 文件大小50MB
    //D:/copy.exe D:/test.avi D:/code/test.avi
    FILE* fp1=fopen(argv[1],"rb");
    FILE* fp2=fopen(argv[2],"wb");
    
    if(!fp1||!fp2)
    {
        printf("复制文件出错\n");
        return -2;
    }
    
    char* temp=(char*)malloc(sizeof(char)*SIZE);
    int count=0;
    while(!feof(fp1))
    {
        memset(temp,0,SIZE);
        //fread(temp,sizeof(char),SIZE,fp1);
       // fwrite(temp,sizeof(char),SIZE,fp2);		//拷贝完成后，文件大小多了几十字节
    //原因是，最后一次拷贝，可能剩余的文件内容小于1024字节，实际还是拷贝了1024的大小，所以拷贝后更大了
        //可以把写入文件的操作写成这样来解决这个问题：
        count=fread(temp,sizeof(char),SIZE,fp1);		//可以修改每次拷贝的数据块的大小到合适的值，使拷贝速度更快
        fwrite(temp,sizeof(char),count,fp2);
    }
    free(temp);
    fclose(fp1);
    fclose(fp2);		
    
    return 0;
}
```

```c
#include<sys/types.h>
#include<sys/stat.h>

#define SIZE 1024*1024*8		//设置单次拷贝数据块大小为8MB
int main(int argc,char* argv[])
{
    for(int i=0;i<argc;i++)
    {
        printf("%s\n",arfv[i]);
    }
    
    //用户输入参数缺少
    if(argc<3)
    {
        printf("缺少参数\n");
        return -1;
    }
    
    //argv[0] 程序名称 文件大小50MB
    //D:/copy.exe D:/test.avi D:/code/test.avi
    FILE* fp1=fopen(argv[1],"rb");
    FILE* fp2=fopen(argv[2],"wb");
    
    if(!fp1||!fp2)
    {
        printf("复制文件出错\n");
        return -2;
    }
    char* temp=NULL;
    int realSize=0;
    struct stat st;
    stat(argv[1],st);
    if(st.st_size>SIZE)		//根据文件实际大小开辟空间
    {
        temp=(char*)malloc(sizeof(char)*SIZE);
        realSize=SIZE;
    }
    else
    {
        temp=(char*)malloc(sizeof(char)*(st.st_size+10));
        realSize=st.st_size+10
    }
    
    int count=0;
    while(!feof(fp1))
    {
        memset(temp,0,realSize);
        count=fread(temp,sizeof(char),realSize,fp1);		//可以修改每次拷贝的数据块的大小到合适的值，使拷贝速度更快
        fwrite(temp,sizeof(char),count,fp2);
    }
    free(temp);
    fclose(fp1);
    fclose(fp2);		
    
    return 0;
}
```



### 4、获取文件的状态

```c
#include<sys/types.h>
#include<sys/stat.h>
int stat(const char* path,struct stat* buf);
```

* 功能：获取文件状态信息
* 参数：
    * path：文件名
    * buf：保存文件信息的结构体
* 返回值：
    * 成功：0
    * 失败：-1

```c
//文件信息结构体
struct stat
{
    dev_t st_dev;				//文件的设备编号
    ino_t st_ino;				//节点
    mode_t st_mode;				//文件的类型和存取的权限
    nlink_t st_nlink;			//链接到该文件的硬链接的数目，刚建立的文件的该值为 1
    uid_t st_uid;				//用户 ID
    gid_t st_gid;				//组 ID
    dev_t st_rdev;				//(设备类型)若此文件为设备文件，则为其设备编号
    off_t st_size;				//文件字节数（文件大小）
    unsigned long st_blksize;	//块大小（文件系统的 I/O 缓冲区大小）
    unsigned long st_blocks;	//块数
    time_t st_atime;			//最后一次访问时间
    time_t st_mtime;			//最后一次修改时间
    time_t st_ctime;			//最后一次改变时间（指属性）
};
```

```c
#include<sys/types.h>
#include<sys/stat.h>
//获取文件状态
int main()
{
    ////文件信息结构体变量
    struct stat st;
    stat("D:/copy.eex",&st);
    printf("文件大小：%d\n"，st.st_size);		//输出文件的大小（单位：字节）
    
    return 0;
}
```

### 5、文件的随机读写

1）fseek() 函数

```c
#include<stdio.h>
int fseek(FILE* stream,long offset,int whence);
```

* 功能：移动文件流（文件光标）的读写位置
* 参数：
    * stream：已经打开的文件指针
    * offset：根据 whence 来移动的位数（偏移量），可以是正数，亦可以是负数。正数表示相对于 whence 往右移动，负数表示相对于 whence 往左移动。如果向左移动的字节数超过了文件开头则报错返回，如果向右移动的字节数超过了文件末尾则再次写入时将增大文件大小
    * whence，其取值如下：
        * SEEK_SET：从文件开头移动 offset 个字节（宏定义值为 0）
        * SEEK_CUR：从当前位置移动 offset 个字节（宏定义值为 1）
        * SEEK_END：从文件末尾移动 offset 个字节（宏定义值为 2）
* 返回值：
    * 成功：0
    * 失败：-1

```c
//文件随机读写

/*
a.txt 内容：
123456789
你瞅啥
瞅你咋地
再瞅一个试试
对不起大哥 我错了
*/
int main()
{
    FILE* fp=fopen("D:/a.txt","wb");
    if(!fp)
        return -1;
    char arr[100];
    memset(arr,0,100);
    
    fgets(arr,100,fp);
    printf("%s\n",arr);		//输出：123456789
    fgets(arr,100,fp);
    printf("%s\n",arr);		//输出：你瞅啥
    
    //文件随机读写
    fseek(fp,-8,SEEK_CUR);
    fgets(arr,100,fp);
    printf("%s\n",arr);		//输出：你瞅啥
    
    //从文件起始位置开始偏移
    fseek(fp,11,SEEK_SET);
    fgets(arr,100,fp);
    printf("%s\n",arr);		//输出：你瞅啥
    
    ////从文件末尾位置开始偏移
    fseek(fp,-17,SEEK_END);
    fgets(arr,100,fp);
    printf("%s\n",arr);		//输出：对不起大哥 我错了
    
    fclose(fp);
    return 0;
}
```



2）ftell() 函数

```c
#include<stdio.h>
long ftell(FILE* stream);
```

* 功能：获取文件流的读写位置
* 参数：stream，打开的文件指针
* 返回值：
    * 成功：当前文件流的读写位置
    * 失败：-1

```c
//在文件中间指定位置添加内容
/*
a.txt 内容：
123456789
你瞅啥
瞅你咋地
再瞅一个试试
对不起大哥 我错了
*/
int main()
{
    FILE* fp=fopen("D:/a.txt","r+");	//使用 "a" 的模式打开，存在缓冲区的问题，导致使用 fseek 操作文件流可能会不起作用，最终添加的内容还是添加在文件末尾
    if(!fp)
        return -1;
    fseek(fp,-17,SEEK_END);
    long pos=ftell(fp);
    printf("%ld\n",p)
    fputs("瞅你咋地\n",fp);
    
    fclose(fp);
    /*文件中的内容修改后为：
    123456789
	你瞅啥
	瞅你咋地
	再瞅一个试试
	瞅你咋地
	对不起大哥 我错了
    */
    return 0;
}
```



3）rewind() 函数

```c
#include<stdio.h>
void rewind(FILE* stream);
```

* 功能：把文件流的读写位置移动到文件开头
* 参数：stream，打开的文件指针
* 返回值：无返回值

```c
frewind(fp);		//与这个语句效果一样：fseek(fp,0,SEEK_SET);
```

### 6、删除文件、重命名文件

1）删除文件

```c
#include<stdio.h>
int remove(const char* pathname);
```

* 功能：删除文件（直接删除了，不会在回收站中出现）
* 参数：pathname，文件名
* 返回值：
    * 成功：0
    * 失败：-1

2）重命名文件

```c
#include<stdio.h>
int rename(const char* oldpath,const char* newpath);
```

* 功能：把 oldname 重命名为 newpath（还具有移动文件的功能，如果新旧文件的路径不同，就直接把文件移动了）
* 参数：
    * oldpath：旧文件名
    * newpath：新文件名
* 返回值：
    * 成功：0
    * 失败：-1

```c
int main()
{
    int value=remove("D:/b.txt");
    if(!value)
        printf("删除成功\n");
    else
        printf("删除失败\n");
    
    int value1=rename("D:/b.txt","D:/abc.txt");
    if(!value1)
        printf("重命名成功\n");
    else
        printf("重命名失败\n");
    
    return 0；
}
```

### 7、文件缓冲区

#### 7.1、文件缓冲区介绍

* 缓冲文件系统是系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区，从内存向磁盘输出的数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘中去；
* 从磁盘向计算机读入数据，则一次从磁盘将一批数据输入到内存缓冲区（充满缓冲区），再从缓冲区逐个地将数据送到程序数据区（给程序变量）。
* 缓冲区是内存的一部分，断电丢失

#### 7.2、磁盘文件的存取

* 磁盘文件，一般保存在硬盘、U盘等掉电不丢失的磁盘设备中，在需要时调入内存
* 在内存中对文件进行编辑处理后，保存到磁盘中
* 程序与磁盘之间交互，不是立即完成，系统或程序可以根据需要设置缓冲区，以提高存储效率

#### 7.3、更新缓冲区

```c
#include<stdio.h>
int fflush(FILE* stream);
```

* 功能：更新缓冲区，让缓冲区数据立马写到文件中
* 参数：stream，文件指针
* 返回值：
    * 成功：0
    * 失败：-1

```c
int main()
{
    FILE* fp=fopen("D:/a.txt","w+");
    if(!fp)
        return -1;
    char ch;
    while(1)
    {
        scanf("%c",&ch);
        if(ch=='@')
            break;
        fputc(ch,fp);
        //频繁地个硬盘交互，损伤硬盘，不建议频繁地更新缓冲区
        fflush(fp);
    }
    
    fclose(fp);
    return 0;
}
```

### 8、实战项目-快译通

#### 8.1、核心代码

**dict.c：** 

```c
#include<stdlib.h>
#include<math.h>
#include<time.h>
#include<stdio.h>
#include<dict.h>
#define SIZE 3

/*
1、创建结构体，存储单词和解释
2、读取单词，格式化存储对应的堆空间中
3、单词查找
4、销毁堆空间
*/

/*
单词库文件，dict.txt:
#a
Trans:art. 一；字母A
#a.m.
Trans:n. 上午
#a/c
Trans:n. 往来账户@往来：come - and - go；contact；intercourse@n. 往来账户
*/

int getWord()
{
    FILE* fp=fopen("D:/dict.txt","r");
    if(!fp)
    {
        printf("加载单词库失败\n");
        return -1;
    }
    list=(dict*)malloc(sizeof(dict)*SIZE);
    
    index=(pos*)malloc(sizeof(pos)*27);
    char flag='a';	//记录当前索引标志位
    int idx=0;		//记录对应字母的索引
    index[0].start=0;	//记录 a 的索引
    index[0].end=0;
    
    //数组下标
    int i=0;
    char* temp=(char*)malloc(sizeof(char)*1024);
    while(!feof(fp))
    {
        memset(temp,0,1024);
        fgets(temp,1024,fp);
        
        //去掉单词末尾的换行符
        temp[strlen(temp)-1]=0;
        
        //开辟单词的堆空间
        list[i].word=(char*)malloc(sizeof(char)*(strlen(temp)));
        //将单词放在指定的堆空间中
        //从第二个字符开始存放，去掉开头的 #
        strcpy(list[i].word,&temp[1]);
        
        //0-25 分别存放不同字母开头的单词
        //0-25 index[0].start	index[0].end
        //创建索引
        if(idx!=26)
        {
            if(list[i].word[0]==flag)
        	{
            	index[idx].end++;
            
        	}
        	else
        	{
            	idx++;
            	index[idx].start=index[idx-1].end;
            	index[idx].end=index[idx-1].end;
            	flag++;
        	}
        }
        
        
        //去掉翻译末尾的换行符
        temp[strlen(temp)-1]=0;
        
        memset(temp,0,1024);
        fgets(temp,1024,fp);
        list[i].trans=(char*)malloc(sizeof(char)*(strlen(temp)-5));		//开辟内存的时候去掉前面多的内容，不需要存储
        //从第七个字符开始存放，去掉开头的 Trans:
        strcpy(list[i].trans,&temp[6]);
        
        //输出
        printf("%s\n",list[i].word);
        printf("%s\n",list[i].trans);
        
        i++;
    }
    //记录中文的索引
    index[26].start=index[25].end;
    index[26].end=SIZE;
    
    //释放堆空间和关闭文件
    free(temp);
    fclose(fp);
    
    return i;
}

int searchWord(const char* word,const char* trans,int idx)
{
    if(!word||!trans)
    {
        printf("输入异常\n");
        return -1;
    }
    
    for(int i=index[idx].start;i<index[idx].end,i++)
    {
        if(!strcmp(word,list[i].word))	//相同
        {
            strcpy(trans,list[i].trans);
            return 0;
        }
    }
    return 1;
}

//数据销毁
void destroySpace()
{
    if(!list)
        return;
    if(index)
    {
        free(index);
        index=NULL;
    }
    for(int i=0;i<SIZE;i++)
    {
        free(list[i].word);
        free(list[i].trans);
        
    }
    free(list);
    list=NULL;
}


int main()
{
    //获取单词库
    int wordCnt=getWord();
    
    //接收用户输入的单词
    char* word=(char*)malloc(sizeof(char)*1024);
    //根据单词提供的翻译
    char* trans=(char*)malloc(sizeof(char)*1024);
    int idx=0;
    while(1)
    {
        memset(word,0,1024);
        memset(trans,0,1024);
        //scanf("%s",word);
        //scanf("%[^\n]",word);
        gets(word);
        
        //出口
        if(!strcmp(word,"comm=exit"));
        
        //0-26
        if(*word>='a'&&*word<='z')
        {
            idx=*word-'a';
        }
        else
        {
            idx=26;
        }
        if(!searchWord(word,trans,idx))
        {
            printf("%s\n",trans);
        }
        else
        {
            printf("未找到该单词\n");
        }
        
    }
    
    //销毁空间
    free(word);
    free(trans);
    destroySpace();
    
    return 0;
}
```

**dict.h：**

```c
#pragma once
#include<stdlib.h>
typedef struct DICT
{
    char* word;
    char* trans;
}dict;

typedef struct POSTION
{
	int start;
    int end;
}pos;

//记录单词的下标
pos* index=NULL;

dict* list=NULL;

//函数的声明

//获取单词库
int getWord();

//查找单词
int searchWord(const char* word,const char* trans,int idx);

//销毁空间
void destroySpace();
```

#### 8.2、索引

1）单词库文件行数

```c
int main()
{
    FILE* fp=fopen("D:/dict.txt","r");
    if(!fp)
    {
        return -1;
    }
    
    char* p=(char*)malloc(sizeof(cahr)*1024);
    int i=0;
    while(!feof(fp))
    {
        fgets(p,1024,fp);
        i++;
    }
    printf("%d\n",i);
    fclose(fp);
    return 0;
}
```

在快译通中添加每个字母开头的单词的索引，加快搜索速度。

## 十、Unix/Linux操作系统

### 1、Unix/Linux操作系统介绍

#### 1.1、操作系统的作用

1）操作系统的目标

* 方便：使计算机系统易于使用
* 有效：以更有效的方式使用计算机系统资源
* 扩展：方便用户有效开发、测试、引进新功能

2）操作系统的地位

* 操作系统在计算机系统中有承上启下的地位，向下封装硬件，向上提供操作接口

#### 1.2、Unix/Linux操作系统介绍

1）Unix 家族

* 1965年，贝尔实验室，MULTICS 操作系统，失败
* 1969年，Unix 之父，Unics -> Unix，B语言和汇编语言
* 1971年，Unix 之父，C语言，C语言重写 Unix
* 1974年，Unix 流行开来
* 1980年，BSD Unix 和 AT&T 的 Unix
* 1982年，Unix System III，不再开原
* 1992-2001年，版权问题，两个 Unix 分枝逐渐衰败

2）Linux 家族

* Minix（mini-Unix），教学使用
* 1990年，Linus，1991年，Linux 内核正式发布
* Linux 系统的发展五个支柱：Unix 操作系统、minix 操作系统、GNU 计划、PUSIX 标准和互联网
* GNU 计划：GNU is Not Unix，包括：EMACS编辑系统、Bash shell程序、GCC、GDB等开发工具
* 1992年，Linux 和 GNU 软件结合 -> GNU/Linux（简称 Linux）
* POSIX 标准：操作系统应该为应用程序提供的接口标准，提高通用性和可移植性

3）Linux 的两类用户

* 知道自己在用 Linux：Linux 电脑系统
* 不知道自己在用 Linux：处理器、安卓内核等

4）Linux 的远亲

* macOS -> Darwin -> BSD -> unix

5）Linux 和 Unix 的联系

* Unix 是工作站上最常用的操作系统，多用户、多任务、实时，但是昂贵
* Linux，类 Unix，免费，Unix兼容的

6）Linux 内核及发行版本介绍

* 内核：运行程序和管理磁盘、打印机等一那件设备的核心程序，提供了一个在裸设备和应用程序之间的抽象层
* Linux 发行版：通常包含了桌面环境、办公套件、媒体播放器、数据库等应用软件

7）Unix/Linux 开发应用领域

* Unix/Linux 服务器
* 嵌入式 Linux 系统
* 桌面应用
* 电子政务

### 2、文件系统

#### 2.1、目录和路径

1）目录

* 目录是一组相关文件的集合
* 一个目录下面除了可以存放文件之外，还可以存放其他目录，即包含子目录
* 在确定文件、目录位置时，DOS 和 Linux/Unix 都采用 “路径名+文件名” 的方式。路径反映的是目录与目录之间的关系

2）路径

* Unix/Linux 路径由到达定位文件的目录组成。在Unix/Linux 中使用正斜杠 "/" 分割路径中的目录，在 DOS 中使用反斜杠 "\" 来分割。
* 相对路径和绝对路径：
    * 绝对路径：从根目录开始
    * 相对路径：目标目录相对于当前目录的位置。 "." 代表当前目录，".."代表当前目录的上级目录

#### 2.2、文件系统

1）Linux 和 Windows 文件系统的区别

* Windows 下目录都是起始于各个驱动器盘符（ A 盘和 B 盘是以前的软盘，现在不使用软盘，因此都从 C 盘开始）
* Linux 下没有驱动器盘符，只有目录，都是起始于相同的根目录 "/"

2）Linux 目录结构

* /：根目录
* /bin：/usr/bin：可执行二进制文件的目录，例如常用命令：ls、tar、mv、cat 等都在该目录下
* /boot：放置 Linux 启东市需要用到的一些文件，如内核文件、系统引导管理器等
* /dev：存放设备文件
* /etc：存放系统配置文件
* /home：系统默认的用户家目录
* /lib：/usr/lib：/usr/local/lib：系统使用的函数库目录
* /lost+fount：系统产生错误时，会讲一些遗失的片段放置在该目录下
* /mnt：/media：光盘的默认挂载点
* /opt：主机安装额外软件的安装目录
* /proc：存放系统核心数据、外部设备、网络状态等
* /root：系统管理员 root 的家目录
* /sbin：/use/sbin：/usr/local/sbin：放置系统管理员可以使用的可执行命令
* /tmp：一般用或者正在执行的程序临时存放文件的目录
* /srv：服务启动之后需要访问的数据目录
* /usr：应用程序的存放目录
* /var：放置系统执行过程中经常变化的文件

#### 2.3、一切皆文件

1）一切皆文件

* Unix/Linux 对数据文件、程序文件、设备文件、网络文件等的关林都抽象为文件，使用统一的方式进行管理
* 文件不通过后缀拓展名进行区分，可以没有拓展名，通过文件类型进行区分

2）文件分类

通常，Unix/Linux 中常用的文件类型有五种：普通文件、目录文件、设备文件、管道文件、链接文件

* 普通文件：存放数据、程序等信息的文件，一般包括文本文件、数据文件、可执行的二进制文件
* 目录文件：Unix/Linux 系统将目录看成是一种特殊的文件，利用它构成文件系统的树型结构
* 设备文件：Unix/Linux 系统把每一个设备都映射成一个设备文件，分为字符设备文件和块设备文件。字符设备的存取以字符为单位，块设备的存取以字符块为单位
* 管道文件：Unix/Linux 系统中用于进程间通信
* 链接文件：类似于 Windows 下的快捷方式，分为软链接和硬链接

#### 2.4、文件权限

1）访问用户

通过访问用户方式分为三种：

* 只允许用户自己访问（所有者）
* 允许一个预先设定的用户组中的用户访问（用户组）
* 允许系统中的任何用户访问（其他用户）

2）访问权限

* 读权限：r
* 写权限：w
* 可执行权限：x

3）说明

* 文件权限由 10 个字母表示
* 第一个字母时文件类型，d 表示目录文件，- 表示普通文件，c 表示硬件字符设备文件，b 表示硬件块设备文件，s 表示管道文件，l表示软链接文件
* 后面九个字母分成三组，每组三个。第一组是所有者权限，第二组是用户组权限，第三组是其他用户权限。权限的三个字母为;rwx，分别代表：读、写、执行。相应的字母表示该类用户具有相应的权限，- 表示该类用户不具有相应的权限

### 3、常用命令

#### 3.1、概述

常用的 Linux 命令大概200多个，需要记住的大概 20%

#### 3.2、命令使用方法

1）Linux 命令格式

**command [-options] [parameter1] [parameter2]...** 

* command：命令名
* [ioptions]：选项，用来对命令进行控制，可以省略
* parameter：传给命令的参数，可以使零个或者多个

2）--help 选项查看命令帮助文档

* --help 选项：一般是 Linux 命令自带的帮助信息，不是所有的命令都自带这个选项
* 例如，查看 ls 命令的帮助信息：ls --help

3）man 命令查看帮助手册

* man 是 Linux 提供的一个手册，包含了大部分的命令、函数的使用说明
* man 中包含多个章节，可以指定不同的章节查看
* man command，可以查看当前命令的说明

4）使用技巧

* 自动补全命令：敲出命令前几个字符之后，按 Tab 可以自动补全命令
* 历史命令：上下键，history 命令

#### 3.3、常用命令

1）文件管理

* 查看文件信息：ls，list 缩写，查看当前目录下的的文件列表

    * ls ./子目录名：查看当前目录子目录的内容
    * ls -a：显示当前目录下所有文件，包含隐藏文件
    * ls -l：以列表形式查看当前目录下所有文件，包括隐藏文件
    * ls -h：配合 -l 以人性化方式显示文件大小
    * 还允许使用通配符来同时引用多个文件名

    |  通配符   |                             含义                             |
    | :-------: | :----------------------------------------------------------: |
    |     *     |                     代表文件名中所有字符                     |
    |  ls te*   |              查看当前目录下所有以 te 开头的文件              |
    | le *html  |             查看当前目录下所有以 html 结尾的文件             |
    |    ？     |                     代表文件名中任意字符                     |
    |  ls ?.c   |           只找点前面一个字符，并且以 .c 结尾的文件           |
    |    []     | 使用 [] 把字符组括起来，表示可以匹配字符组中任意一个，- 表示字符范围 |
    |   [abc]   |                表示匹配 a、b、c 中的任意一个                 |
    |   [a-f]   |                 表示匹配 a 到 f 中的任意一个                 |
    | ls [a-f]* |           查找以 a 到 f 之间任意一个字符开头的文件           |

    **注：要使用通配符字符，需要使用 \ 进行转义；处于方括号内的通配字符不需要转义。例如：ls \*a 表示查看文件名为 *a 的文件** 

2）输出重定向命令

* `>`：可以将命令的输出结果重定向到一个文件，如：ls > test.txt，可以将命令的输出保存到 test.txt 中，如果文件不存在，会创建文件，如果文件存在，**会覆盖其内容**
* `>>`：可以将命令的输出结果重定向到一个文件，如：ls >> test.txt，可以将命令的输出保存到 test.txt 中，如果文件不存在，会创建文件，如果文件存在，**会在文件末尾追加内容**

3）分屏显示

* more：查看内容过长而无法在一屏内显示时，会出现快速滚屏，无法看清。使用 more 命令可以一次只显示一页，空格可以翻页，q 退出

4）管道

* |：一个命令的输出通过管道作为另一个命令的输入
    * ls -al | more：就可以分屏显示文件列表

5）清屏

* clear
* 快捷键：Ctrl+l

6）切换工作目录

* cd 目标目录路径：切换到目标目录
* cd ..：回到上级目录
* cd：切换到当前用户的主目录，cd ~ 也可以达到相同的效果
* cd .：切换到当前目录
* cd -：切换至上一个进入的目录

**可以使用绝对路径，也可以使用绝对路径** 

**Linux 的目录路径大小写敏感** 

7）显示当前路径

* pwd：显示当前所在路径

8）创建目录

* mkdir：mkdir 目录名，可以创建名为目录名的目录
* mkdir 目录名1 目录名2 ……，可以创建多个目录
* mkdir -p 目录名1/目录名2，可以递归创建目录

9）删除目录：

* mdir：mdir 目录名，可以删除名为目录名的目录，删除时必须离开目录，且目录为空，否则会出错
* mdir 目录名1 目录名2……，可以删除多个目录
* mdir -p 目录名1/目录名2，可以递归删除目录

10）删除文件

* rm：rm 文件名，删除文件，且不可恢复

* rm 常用参数

    | 参数 |                       含义                       |
    | :--: | :----------------------------------------------: |
    |  -i  |               以进行交互的方式执行               |
    |  -f  |       强制删除，忽略不存在的文件，无需提示       |
    |  -r  | 递归地删除目录下的内容，删除文件夹时必须加此参数 |

11）建立链接文件

* ln 源文件 链接文件，建立硬链接，两个文件占用相同大小的硬盘空间，即使删除了源文件，链接文件依然存在
* ln -s 源文件 链接文件，建立软链接
* 软链接：不占用磁盘空间，源文件删除，则软链接失效
* 硬链接：只能链接普通文件，不能链接目录

12）查看或者合并文件内容

* cat：cat 文件名：显示文件内容
* cat 文件名1 文件名2 >> 文件名1，将文件名1和文件名2的内容合并存放到文件名1中

13）拷贝文件

* cp：cp 源文件 目标文件，把源文件拷贝到目标文件中

* 常用选项

    | 选项 |                             含义                             |
    | :--: | :----------------------------------------------------------: |
    |  -a  | 用于拷贝目录时，拷贝时保留链接、文件属性，并递归复制目录，目标文件具有原文件的所有属性 |
    |  -f  |                覆盖已经存在的目标文件而不提示                |
    |  -i  |     交互式复制，在覆盖目标文件之前，给出提示要求用户确认     |
    |  -r  | 若给出的源文件是目录文件，则递归复制该目录下的所有文件和子目录，且目标文件也必须是一个目录文件 |
    |  -v  |                         显示拷贝进度                         |

14）移动文件

* mv：mv 源文件 目标文件，将源文件剪切为目标文件

* 常用选项：

    | 选项 |                      含义                      |
    | :--: | :--------------------------------------------: |
    |  -f  |      禁止交互式操作，如有覆盖也不给出提示      |
    |  -i  | 交互式操作，如果存在覆盖，给出提示要求用户确认 |
    |  -v  |                  显示移动进度                  |

15）获取文件类型

* file：file 文件名，显示文件类型信息

16）归档管理

* tar：tar [参数] 档案文件名 文件

* tar 命令比较特殊，其参数前面可以加 -，也可以不加

* 待归档文件可以有多个，依次列出即可

* 常用归档命令格式：tar -cvf 档案名.tar 文件

* 常用解档命令格式：tar -xvf 待解档文件

* 常用参数：

    | 参数 |                      含义                      |
    | :--: | :--------------------------------------------: |
    |  -c  |           生成归档文件，创建打包文件           |
    |  -v  |        列出归档解档的详细过程，显示进度        |
    |  -f  | 指定方案文件名称，这个参数必须放在所有参数最后 |
    |  -t  |              列出档案中包含的文件              |
    |  -x  |                  揭开档案文件                  |

    **注：只有参数 f 需要放在最后面，其他的参数没有顺序要求**

17）文件压缩解压

**gzip** 

* gzip：gzip [选项] 被压缩文件名

* tar 命令和 gzip 命令结合使用实现文件打包、压缩

* tar 只负责文件打包，但不压缩，用 gzip 压缩后的 tar 打包文件，其名称一般为：XXX.tar.gz

* 常用选项

    | 选项 |      含义      |
    | :--: | :------------: |
    |  -d  |      解压      |
    |  -r  | 压缩所有子目录 |

* 压缩已归档文件：gzip -r XXX.tar

    * 原本的 XXX.tar 文件就被 XXX.tar.gz 覆盖了

* 常用解压缩命令格式：gzip -d XXX.tar.gz

    * 原本的 XXX.tar.gz 文件就被 XXX.tar 覆盖了
    * 解档：tar -xvf XXX.tar

* 一步归档压缩：tar -zcvf xxx.tar.gz 1.c 2.c 3.c

    * 1.c 2.c 3.c 归档压缩为xxx.tar.gz

* 一步解压缩解档：tar -xzvf xxx.tar.gz

**bzip2** 

* bzip2：和 gzip 作用一样，文件名一般为：xxx.tar.bz2
    * 压缩：tar -cjvf xxx.tar.bz2 待压缩文件名们
    * 解压：tar -xjvf xxx.tar.bz2

**zip、unzip** 

* zip：zip 目标文件 文件名们
    * 通过 zip 压缩文件的目标文件不需要指定扩展名，默认为 zip
* 压缩：zip [-r] 目标文件 源文件们
    * 生成：目标文件.zip
* 解压：unzip -d 解压后目录文件 压缩文件
    * 解压到`解压后目录文件`文件夹内

18）查看命令位置

* which：which 命令名，查看命令的存放位置
    * which ls，查看 ls 命令的存放位置

#### 3.4、用户、权限管理命令

1）查看当前用户：whoami

* whoami，查看当前系统当前账号的用户名
* 可以通过 cat /etc/passwd 查看系统用户信息
* su：切换至 root 用户
* su 用户名：切换至`用户名` 用户

2）退出登录账户：exit

* 如果是图形界面，exit 会关闭终端
* 如果是 ssh 远程登录，会退出登录账户
* 如果是切换后的登录用户，exit 会返回上一个登录用户

3）切换用户：su

* su 用户名：命令切换用户
* su - 用户名：也可以切换用户，并且在切换到目标用户之后，会自动切换到当前用户的主目录
* su：切换至 root 用户
* 设置 root 用户密码：sudo passwd

4）添加、删除组账号：groupadd、groupdel

* groupadd 用户名：新建的组账号
* groupdel 用户名：删除组账号，组内没有成员才可以删除组
* cat /etc/group：查看用户组

5）修改用户所在组：usermod

* usermod -g 用户组名 用户名：把用户添加到用户组内

6）添加用户账号：useradd

* useradd [参数] 新建用户账号

* adduser [参数] 新建用户账号

* 参数说明

    | 参数 |                             含义                             |
    | :--: | :----------------------------------------------------------: |
    |  -d  | 指定用户登录系统时的主目录。如果不指定，系统自动在 /home 目录下建立与用户名同名的目录为主目录 |
    |  -a  |                         自动建立目录                         |
    |  -g  |                          指定组名称                          |

7）删除用户：userdel

* userdel 用户名：删除用户，但不会自动删除用户的主目录
* userdel -r 用户名：删除用户，同时删除用户的主目录

8）查询用户登录情况：last

* 管理员可以通过 last 命令查看每位用户的登录情况，登录地址

9）修改文件权限：chmod

* chmod 修改文件权限有两种格式：字母法和数字法

    * 字母法：chmod u/g/o/a +/-/= rwx 文件名

        | 符号 |         含义          |
        | :--: | :-------------------: |
        |  u   |   user，文件所有者    |
        |  g   | group，同一用户组用户 |
        |  o   |  other，其他以外的人  |
        |  a   |     all，三者皆是     |
        |  +   |       增加权限        |
        |  -   |       撤销权限        |
        |  =   |       设定权限        |

        * 例如：chmod go -r a.txt		撤销 g 和 o 的读权限
        * chmod a+x b.txt                    为 a 增加 x 权限
        * chmod u=rw abc.txt               设定 u 的权限为 rw

    * 数字法：rwx 这些权限可以使用数字来代替，rwx 组成三位二进制，组成的值就是对应的数字值

    | 权限 |     数字代号      |
    | :--: | :---------------: |
    |  r   |     读权限，4     |
    |  w   |         2         |
    |  x   |         1         |
    |  -   | 不具有任何权限，0 |

    * 例如：chmod u=7,g=5,o=4 filename	与	chmod u=rwx,g=rx,o=r filename	等价
    * chmod 751 file
        * 文件所有者：rwx
        * 同组用户：rx
        * 其他用户：x

10）修改文件所有者：chown

* chown 用户名 文件名：将文件的所有者修改为指定用户

11）修改文件所属组：chgrp

* chgrp 用户组名 文件名：将文件的所属组修改为指定用户组

#### 3.5、系统管理

1）查看进程信息：ps

* 进程是一个具有一定独立功能的程序，他是操作系统动态执行的基本单元

* ps 命令常用的选项：

    | 选项 |                   含义                   |
    | :--: | :--------------------------------------: |
    |  -a  | 显示终端上的所有进程，包括其他用户的进程 |
    |  -u  |            显示进程的详细状态            |
    |  -x  |          显示没有控制终端的进程          |
    |  -w  |       显示加宽，以便显示更多的信息       |
    |  -r  |           只显示正在运行的进程           |

* top 命令：动态显示进程，还可以进行条件检索

2）终止进程：kill

* kill [-signal] pid：终止指定 pid 的进程
* kill 命令指定进程的进程号，需要配合 ps 命令使用
* signal 的值从 0 到 15，其中 9 为绝对终止，可以处理一般信号无法终止的进程

3）后台程序：&、jobs、fg

* 用户可以后台执行程序：命令 &
* 如果程序已经在执行，ctrl+z 可以将程序调入后台
* jobs：查看后台执行的程序
* fg 编号：将后台程序调出到前台，编号是通过 jobs 查看的编号

4）关机、重启：reboot、shutdown、init

|       命令        |             含义             |
| :---------------: | :--------------------------: |
|      reboot       |         重启操作系统         |
|  shutdown -r now  | 重启操作系统，并提示其他用户 |
|  shutdown -h now  |           立刻关机           |
| shutdown -h 20:35 |    系统在今天 20:35 关机     |
|  shutdown -h +10  |       系统十分钟后关机       |
|      init 0       |             关机             |
|      init 6       |             重启             |

5）字符界面和图形界面切换

* Redhat 平台下：

    | init 3 | 切换到字符界面 |
    | :----: | :------------: |
    | init 5 | 切换到图形界面 |

* 其他大部分平台：

    | ctrl+alt+F2 | 切换到字符界面 |
    | :---------: | :------------: |
    | ctrl+alt+F7 | 切换到图形界面 |

6）查看或配置网卡信息：ifconfig

* ifconfig：显示所有网卡的信息

    |  显示字段   |                             说明                             |
    | :---------: | :----------------------------------------------------------: |
    |    eth0     |                         网络接口名称                         |
    | Link encap  |                         链路封装协议                         |
    |   Hwaddr    |                       网口的 MAC 地址                        |
    |  Inet addr  |                           IP 地址                            |
    |    Bcast    |                           广播地址                           |
    |    Mask     |                           子网掩码                           |
    |     UP      |       网口状态识别，UP表示已经启用，DOWN 表示已经停用        |
    |  BROADCAST  |                广播标识，标识广播是否支持广播                |
    |   RUNNING   |          传输标识，标识网口是否已经开始传输分组数据          |
    |  MULTICAST  |                多播标识，标识网口是否支持多播                |
    | MTU, Metric | MTU：最大传输单位，单位：字节；Metric：度量值，用户 RIP 建立网络路由用 |
    |  RX bytes   |                       接收数据字节统计                       |
    |  TX bytes   |                       发送数据字节统计                       |

* ifconfig 还可以配置网络参数;

    * ifconfig 网口名称 [地址协议参数] [address] [参数]
    * 地址协议参数：inet，表示 IPv4；inet6：表示 IPv6
    * 例如：ifconfig eth0 inet 192.168.10.254 netmask 255.255.255.0 up

* 常用参数

    |        参数        |       功能       |
    | :----------------: | :--------------: |
    |         -a         | 显示所有网口状态 |
    |   inet [IP 地址]   |   设置 IP 地址   |
    | netmask [子网掩码] |   设置子网掩码   |
    |         up         |     启用网口     |
    |        down        |     关闭网口     |

* ifconfig 配置的网络参数存放在内存中，关机重启就失效了。如果需要持久有效，需要修改网口配置文件：

    * redhat：/etc/sysconfig/network-scripts/ifcfg-eth0 文件：

        ```bash
        IPADDR=IP 地址
        GATEWAY=默认网关
        ```

    * Ubuntu：/etc/NetworkManager/system-connections/Wired connection1 文件：

        ```bash
        [ipv4]
        method=manual
        addresses1=IP 地址;24;默认网关;
        ```

7）测试远程主机连通性：ping

* ping [参数] 远程主机 IP 地址
* ping 通过 ICMP 协议向远程主机发送 ECHO_REQUEST 请求，期望主机回复 ECHO_REPLAY 消息
* 通过 ping 命令可以检查是否与远程主机建立了 TCP/IP 连接

### 4、编辑器

#### 4.1、gedit 编辑器

Linux 下的一个文本编辑器

#### 4.2、vi 编辑器

1）vi 介绍：编辑器之神

2）vi 基本操作

* vi filename：打开或者新建文件

2）vi 常用命令

**在命令模式下进入插入模式：**

* a：光标位置右边插入文字
* i：光标位置当前处插入文字
* o：光标位置下方开启新行
* O：光标位置上方开启新行
* I：光标所在行首插入文字
* A：光标所在行尾插入文字

**vi 的退出：**

* shitf+z+z：保存退出
* `:wq`：保存退出
* `:x`：保存退出
* `:w filename`：保存到指定文件
* `:q`：退出，如果文件修改但是没有保存，会提示无法退出
* `:q！`：退出，不保存
* `:！命令`：暂时离开 vi，执行命令

**vi 的删除和修改功能：**

* [n]x：删除光标后 n 个字符
* [n]X：删除光标前 n 个字符
* D：删除光标所在位置开始到此行行尾的字符
* [n]dd：删除从当前行开始的 n 行（实际上是剪切）
* [n]yy：复制从当前行开始的 n 行
* p：把粘贴板上的内容插入到当前行
* dG：删除光标所在行到文件尾的所有字符
* J：合并两行（将下一行和当前行合并，用空格连接）
* .：执行上一次操作
* u：撤销前一个命令

**vi 的定位和查找功能：**

* ctrl+f：向前滚动一个屏幕
* ctrl+b：向后滚动一个屏幕
* gg：到文件第一行行首
* G：到文件最后一行行首
* `:$`：到文件最后一行行首
* [n]G 或者[n]gg：到指定行，n 为目标行数
* /字符串：查找指定字符串
* n：寻找下一个
* N：回到前一个
* ？：寻找上一个
* /~字符串：寻找以字符串开始的行
* /字符串$：寻找以字符串结尾的行
* /a.b：查找字符串 a 任意字符 b

**vi 的替换和设置指令：**

* r：替换当前光标字符（很少用）
* `:r 文件名`:在光标当前位置下一行载入另一个文件
* `:s/p1/p2/g`：将当前行中所有的 p1 用 p2 替换
* `:g/p1/s/p2/g`：将当前文件中所有的 p1 用 p2 替换
* `:n1,n2s/p1/p2/g`：将 n1 到 n2 行中所有的 p1 用 p2 替换
* `:set ic`：搜寻时不区分大小写
* `:set noic`：搜寻时区分大小写
* `:set nu`：显示行号
* `:set nunu`：不显示行号

### 5、远程操作

#### 5.1、ssh介绍

* ssh：Source shell

#### 5.2、远程登录

1）Linux 平台相互远程

```bash
ssh -l username hostip
```

2）Windows 远程登录 Linux

Xmanager、Xshell、Xftp……

#### 5.3、远程文件传输

### 6、webserver 搭建

